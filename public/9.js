(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[9],{

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! regenerator-runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanM/YTM0YSJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJyZWdlbmVyYXRvci1ydW50aW1lXCIpO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n");

/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n   true ? module.exports : undefined\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcz85NmNmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgQXN5bmNJdGVyYXRvci5wcm90b3R5cGVbYXN5bmNJdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gQSAudGhyb3cgb3IgLnJldHVybiB3aGVuIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgbm8gLnRocm93XG4gICAgICAvLyBtZXRob2QgYWx3YXlzIHRlcm1pbmF0ZXMgdGhlIHlpZWxkKiBsb29wLlxuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIC8vIE5vdGU6IFtcInJldHVyblwiXSBtdXN0IGJlIHVzZWQgZm9yIEVTMyBwYXJzaW5nIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIC8vIElmIHRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBoYXMgYSByZXR1cm4gbWV0aG9kLCBnaXZlIGl0IGFcbiAgICAgICAgICAvLyBjaGFuY2UgdG8gY2xlYW4gdXAuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuXG4gICAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIC8vIElmIG1heWJlSW52b2tlRGVsZWdhdGUoY29udGV4dCkgY2hhbmdlZCBjb250ZXh0Lm1ldGhvZCBmcm9tXG4gICAgICAgICAgICAvLyBcInJldHVyblwiIHRvIFwidGhyb3dcIiwgbGV0IHRoYXQgb3ZlcnJpZGUgdGhlIFR5cGVFcnJvciBiZWxvdy5cbiAgICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICd0aHJvdycgbWV0aG9kXCIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpO1xuXG4gICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICB2YXIgaW5mbyA9IHJlY29yZC5hcmc7XG5cbiAgICBpZiAoISBpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICAvLyBBc3NpZ24gdGhlIHJlc3VsdCBvZiB0aGUgZmluaXNoZWQgZGVsZWdhdGUgdG8gdGhlIHRlbXBvcmFyeVxuICAgICAgLy8gdmFyaWFibGUgc3BlY2lmaWVkIGJ5IGRlbGVnYXRlLnJlc3VsdE5hbWUgKHNlZSBkZWxlZ2F0ZVlpZWxkKS5cbiAgICAgIGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlO1xuXG4gICAgICAvLyBSZXN1bWUgZXhlY3V0aW9uIGF0IHRoZSBkZXNpcmVkIGxvY2F0aW9uIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICAvLyBJZiBjb250ZXh0Lm1ldGhvZCB3YXMgXCJ0aHJvd1wiIGJ1dCB0aGUgZGVsZWdhdGUgaGFuZGxlZCB0aGVcbiAgICAgIC8vIGV4Y2VwdGlvbiwgbGV0IHRoZSBvdXRlciBnZW5lcmF0b3IgcHJvY2VlZCBub3JtYWxseS4gSWZcbiAgICAgIC8vIGNvbnRleHQubWV0aG9kIHdhcyBcIm5leHRcIiwgZm9yZ2V0IGNvbnRleHQuYXJnIHNpbmNlIGl0IGhhcyBiZWVuXG4gICAgICAvLyBcImNvbnN1bWVkXCIgYnkgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yLiBJZiBjb250ZXh0Lm1ldGhvZCB3YXNcbiAgICAgIC8vIFwicmV0dXJuXCIsIGFsbG93IHRoZSBvcmlnaW5hbCAucmV0dXJuIGNhbGwgdG8gY29udGludWUgaW4gdGhlXG4gICAgICAvLyBvdXRlciBnZW5lcmF0b3IuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIEdwW3RvU3RyaW5nVGFnU3ltYm9sXSA9IFwiR2VuZXJhdG9yXCI7XG5cbiAgLy8gQSBHZW5lcmF0b3Igc2hvdWxkIGFsd2F5cyByZXR1cm4gaXRzZWxmIGFzIHRoZSBpdGVyYXRvciBvYmplY3Qgd2hlbiB0aGVcbiAgLy8gQEBpdGVyYXRvciBmdW5jdGlvbiBpcyBjYWxsZWQgb24gaXQuIFNvbWUgYnJvd3NlcnMnIGltcGxlbWVudGF0aW9ucyBvZiB0aGVcbiAgLy8gaXRlcmF0b3IgcHJvdG90eXBlIGNoYWluIGluY29ycmVjdGx5IGltcGxlbWVudCB0aGlzLCBjYXVzaW5nIHRoZSBHZW5lcmF0b3JcbiAgLy8gb2JqZWN0IHRvIG5vdCBiZSByZXR1cm5lZCBmcm9tIHRoaXMgY2FsbC4gVGhpcyBlbnN1cmVzIHRoYXQgZG9lc24ndCBoYXBwZW4uXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvaXNzdWVzLzI3NCBmb3IgbW9yZSBkZXRhaWxzLlxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBHcC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/regenerator-runtime/runtime.js\n");

/***/ }),

/***/ "./node_modules/vee-validate/dist/rules.js":
/*!*************************************************!*\
  !*** ./node_modules/vee-validate/dist/rules.js ***!
  \*************************************************/
/*! exports provided: alpha, alpha_dash, alpha_num, alpha_spaces, between, confirmed, digits, dimensions, email, excluded, ext, image, integer, is, is_not, length, max, max_value, mimes, min, min_value, numeric, oneOf, regex, required, required_if, size */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha\", function() { return alpha$1; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha_dash\", function() { return alpha_dash; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha_num\", function() { return alpha_num; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"alpha_spaces\", function() { return alpha_spaces; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"between\", function() { return between; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"confirmed\", function() { return confirmed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"digits\", function() { return digits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dimensions\", function() { return dimensions; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"email\", function() { return email; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"excluded\", function() { return excluded; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ext\", function() { return ext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"image\", function() { return image; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"integer\", function() { return integer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"is\", function() { return is; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"is_not\", function() { return is_not; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max_value\", function() { return max_value; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mimes\", function() { return mimes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min_value\", function() { return min_value; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numeric\", function() { return numeric; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"oneOf\", function() { return oneOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regex\", function() { return regex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"required\", function() { return required; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"required_if\", function() { return required_if; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"size\", function() { return size; });\n/**\n  * vee-validate v3.2.5\n  * (c) 2020 Abdelrahman Awad\n  * @license MIT\n  */\n/**\r\n * Some Alpha Regex helpers.\r\n * https://github.com/chriso/validator.js/blob/master/src/lib/alpha.js\r\n */\r\nvar alpha = {\r\n    en: /^[A-Z]*$/i,\r\n    cs: /^[A-Z]*$/i,\r\n    da: /^[A-Z]*$/i,\r\n    de: /^[A-Z]*$/i,\r\n    es: /^[A-Z]*$/i,\r\n    fr: /^[A-Z]*$/i,\r\n    it: /^[A-Z\\xC0-\\xFF]*$/i,\r\n    lt: /^[A-Z]*$/i,\r\n    nl: /^[A-Z]*$/i,\r\n    hu: /^[A-Z]*$/i,\r\n    pl: /^[A-Z]*$/i,\r\n    pt: /^[A-Z]*$/i,\r\n    ru: /^[-]*$/i,\r\n    sk: /^[A-Z]*$/i,\r\n    sr: /^[A-Z]*$/i,\r\n    sv: /^[A-Z]*$/i,\r\n    tr: /^[A-Z]*$/i,\r\n    uk: /^[-]*$/i,\r\n    ar: /^[]*$/,\r\n    az: /^[A-Z]*$/i\r\n};\r\nvar alphaSpaces = {\r\n    en: /^[A-Z\\s]*$/i,\r\n    cs: /^[A-Z\\s]*$/i,\r\n    da: /^[A-Z\\s]*$/i,\r\n    de: /^[A-Z\\s]*$/i,\r\n    es: /^[A-Z\\s]*$/i,\r\n    fr: /^[A-Z\\s]*$/i,\r\n    it: /^[A-Z\\xC0-\\xFF\\s]*$/i,\r\n    lt: /^[A-Z\\s]*$/i,\r\n    nl: /^[A-Z\\s]*$/i,\r\n    hu: /^[A-Z\\s]*$/i,\r\n    pl: /^[A-Z\\s]*$/i,\r\n    pt: /^[A-Z\\s]*$/i,\r\n    ru: /^[-\\s]*$/i,\r\n    sk: /^[A-Z\\s]*$/i,\r\n    sr: /^[A-Z\\s]*$/i,\r\n    sv: /^[A-Z\\s]*$/i,\r\n    tr: /^[A-Z\\s]*$/i,\r\n    uk: /^[-\\s]*$/i,\r\n    ar: /^[\\s]*$/,\r\n    az: /^[A-Z\\s]*$/i\r\n};\r\nvar alphanumeric = {\r\n    en: /^[0-9A-Z]*$/i,\r\n    cs: /^[0-9A-Z]*$/i,\r\n    da: /^[0-9A-Z]$/i,\r\n    de: /^[0-9A-Z]*$/i,\r\n    es: /^[0-9A-Z]*$/i,\r\n    fr: /^[0-9A-Z]*$/i,\r\n    it: /^[0-9A-Z\\xC0-\\xFF]*$/i,\r\n    lt: /^[0-9A-Z]*$/i,\r\n    hu: /^[0-9A-Z]*$/i,\r\n    nl: /^[0-9A-Z]*$/i,\r\n    pl: /^[0-9A-Z]*$/i,\r\n    pt: /^[0-9A-Z]*$/i,\r\n    ru: /^[0-9-]*$/i,\r\n    sk: /^[0-9A-Z]*$/i,\r\n    sr: /^[0-9A-Z]*$/i,\r\n    sv: /^[0-9A-Z]*$/i,\r\n    tr: /^[0-9A-Z]*$/i,\r\n    uk: /^[0-9-]*$/i,\r\n    ar: /^[0-9]*$/,\r\n    az: /^[0-9A-Z]*$/i\r\n};\r\nvar alphaDash = {\r\n    en: /^[0-9A-Z_-]*$/i,\r\n    cs: /^[0-9A-Z_-]*$/i,\r\n    da: /^[0-9A-Z_-]*$/i,\r\n    de: /^[0-9A-Z_-]*$/i,\r\n    es: /^[0-9A-Z_-]*$/i,\r\n    fr: /^[0-9A-Z_-]*$/i,\r\n    it: /^[0-9A-Z\\xC0-\\xFF_-]*$/i,\r\n    lt: /^[0-9A-Z_-]*$/i,\r\n    nl: /^[0-9A-Z_-]*$/i,\r\n    hu: /^[0-9A-Z_-]*$/i,\r\n    pl: /^[0-9A-Z_-]*$/i,\r\n    pt: /^[0-9A-Z_-]*$/i,\r\n    ru: /^[0-9-_-]*$/i,\r\n    sk: /^[0-9A-Z_-]*$/i,\r\n    sr: /^[0-9A-Z_-]*$/i,\r\n    sv: /^[0-9A-Z_-]*$/i,\r\n    tr: /^[0-9A-Z_-]*$/i,\r\n    uk: /^[0-9-_-]*$/i,\r\n    ar: /^[0-9_-]*$/,\r\n    az: /^[0-9A-Z_-]*$/i\r\n};\n\nvar validate = function (value, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate(val, { locale: locale }); });\r\n    }\r\n    // Match at least one locale.\r\n    if (!locale) {\r\n        return Object.keys(alpha).some(function (loc) { return alpha[loc].test(value); });\r\n    }\r\n    return (alpha[locale] || alpha.en).test(value);\r\n};\r\nvar params = [\r\n    {\r\n        name: 'locale'\r\n    }\r\n];\r\nvar alpha$1 = {\r\n    validate: validate,\r\n    params: params\r\n};\n\nvar validate$1 = function (value, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$1(val, { locale: locale }); });\r\n    }\r\n    // Match at least one locale.\r\n    if (!locale) {\r\n        return Object.keys(alphaDash).some(function (loc) { return alphaDash[loc].test(value); });\r\n    }\r\n    return (alphaDash[locale] || alphaDash.en).test(value);\r\n};\r\nvar params$1 = [\r\n    {\r\n        name: 'locale'\r\n    }\r\n];\r\nvar alpha_dash = {\r\n    validate: validate$1,\r\n    params: params$1\r\n};\n\nvar validate$2 = function (value, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$2(val, { locale: locale }); });\r\n    }\r\n    // Match at least one locale.\r\n    if (!locale) {\r\n        return Object.keys(alphanumeric).some(function (loc) { return alphanumeric[loc].test(value); });\r\n    }\r\n    return (alphanumeric[locale] || alphanumeric.en).test(value);\r\n};\r\nvar params$2 = [\r\n    {\r\n        name: 'locale'\r\n    }\r\n];\r\nvar alpha_num = {\r\n    validate: validate$2,\r\n    params: params$2\r\n};\n\nvar validate$3 = function (value, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).locale, locale = _b === void 0 ? '' : _b;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$3(val, { locale: locale }); });\r\n    }\r\n    // Match at least one locale.\r\n    if (!locale) {\r\n        return Object.keys(alphaSpaces).some(function (loc) { return alphaSpaces[loc].test(value); });\r\n    }\r\n    return (alphaSpaces[locale] || alphaSpaces.en).test(value);\r\n};\r\nvar params$3 = [\r\n    {\r\n        name: 'locale'\r\n    }\r\n];\r\nvar alpha_spaces = {\r\n    validate: validate$3,\r\n    params: params$3\r\n};\n\nvar validate$4 = function (value, _a) {\r\n    var _b = _a === void 0 ? {} : _a, min = _b.min, max = _b.max;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return !!validate$4(val, { min: min, max: max }); });\r\n    }\r\n    return Number(min) <= value && Number(max) >= value;\r\n};\r\nvar params$4 = [\r\n    {\r\n        name: 'min'\r\n    },\r\n    {\r\n        name: 'max'\r\n    }\r\n];\r\nvar between = {\r\n    validate: validate$4,\r\n    params: params$4\r\n};\n\nvar validate$5 = function (value, _a) {\r\n    var target = _a.target;\r\n    return String(value) === String(target);\r\n};\r\nvar params$5 = [\r\n    {\r\n        name: 'target',\r\n        isTarget: true\r\n    }\r\n];\r\nvar confirmed = {\r\n    validate: validate$5,\r\n    params: params$5\r\n};\n\nvar validate$6 = function (value, _a) {\r\n    var length = _a.length;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$6(val, { length: length }); });\r\n    }\r\n    var strVal = String(value);\r\n    return /^[0-9]*$/.test(strVal) && strVal.length === length;\r\n};\r\nvar params$6 = [\r\n    {\r\n        name: 'length',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar digits = {\r\n    validate: validate$6,\r\n    params: params$6\r\n};\n\nvar validateImage = function (file, width, height) {\r\n    var URL = window.URL || window.webkitURL;\r\n    return new Promise(function (resolve) {\r\n        var image = new Image();\r\n        image.onerror = function () { return resolve(false); };\r\n        image.onload = function () { return resolve(image.width === width && image.height === height); };\r\n        image.src = URL.createObjectURL(file);\r\n    });\r\n};\r\nvar validate$7 = function (files, _a) {\r\n    var width = _a.width, height = _a.height;\r\n    var list = [];\r\n    files = Array.isArray(files) ? files : [files];\r\n    for (var i = 0; i < files.length; i++) {\r\n        // if file is not an image, reject.\r\n        if (!/\\.(jpg|svg|jpeg|png|bmp|gif)$/i.test(files[i].name)) {\r\n            return Promise.resolve(false);\r\n        }\r\n        list.push(files[i]);\r\n    }\r\n    return Promise.all(list.map(function (file) { return validateImage(file, width, height); })).then(function (values) {\r\n        return values.every(function (v) { return v; });\r\n    });\r\n};\r\nvar params$7 = [\r\n    {\r\n        name: 'width',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    },\r\n    {\r\n        name: 'height',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar dimensions = {\r\n    validate: validate$7,\r\n    params: params$7\r\n};\n\nvar validate$8 = function (value, _a) {\r\n    var multiple = (_a === void 0 ? {} : _a).multiple;\r\n    // eslint-disable-next-line\r\n    var re = /^(([^<>()\\[\\]\\\\.,;:\\s@\"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/;\r\n    if (multiple && !Array.isArray(value)) {\r\n        value = String(value)\r\n            .split(',')\r\n            .map(function (emailStr) { return emailStr.trim(); });\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return re.test(String(val)); });\r\n    }\r\n    return re.test(String(value));\r\n};\r\nvar params$8 = [\r\n    {\r\n        name: 'multiple',\r\n        default: false\r\n    }\r\n];\r\nvar email = {\r\n    validate: validate$8,\r\n    params: params$8\r\n};\n\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\nfunction isEmptyArray(arr) {\r\n    return Array.isArray(arr) && arr.length === 0;\r\n}\r\nfunction isCallable(fn) {\r\n    return typeof fn === 'function';\r\n}\n\nfunction includes(collection, item) {\r\n    return collection.indexOf(item) !== -1;\r\n}\r\n/**\r\n * Converts an array-like object to array, provides a simple polyfill for Array.from\r\n */\r\nfunction toArray(arrayLike) {\r\n    if (isCallable(Array.from)) {\r\n        return Array.from(arrayLike);\r\n    }\r\n    /* istanbul ignore next */\r\n    return _copyArray(arrayLike);\r\n}\r\n/* istanbul ignore next */\r\nfunction _copyArray(arrayLike) {\r\n    var array = [];\r\n    var length = arrayLike.length;\r\n    for (var i = 0; i < length; i++) {\r\n        array.push(arrayLike[i]);\r\n    }\r\n    return array;\r\n}\n\nvar validate$9 = function (value, options) {\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$9(val, options); });\r\n    }\r\n    return toArray(options).some(function (item) {\r\n        // eslint-disable-next-line\r\n        return item == value;\r\n    });\r\n};\r\nvar oneOf = {\r\n    validate: validate$9\r\n};\n\nvar validate$a = function (value, args) {\r\n    return !validate$9(value, args);\r\n};\r\nvar excluded = {\r\n    validate: validate$a\r\n};\n\nvar validate$b = function (files, extensions) {\r\n    var regex = new RegExp(\".(\" + extensions.join('|') + \")$\", 'i');\r\n    if (Array.isArray(files)) {\r\n        return files.every(function (file) { return regex.test(file.name); });\r\n    }\r\n    return regex.test(files.name);\r\n};\r\nvar ext = {\r\n    validate: validate$b\r\n};\n\nvar validate$c = function (files) {\r\n    var regex = /\\.(jpg|svg|jpeg|png|bmp|gif)$/i;\r\n    if (Array.isArray(files)) {\r\n        return files.every(function (file) { return regex.test(file.name); });\r\n    }\r\n    return regex.test(files.name);\r\n};\r\nvar image = {\r\n    validate: validate$c\r\n};\n\nvar validate$d = function (value) {\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return /^-?[0-9]+$/.test(String(val)); });\r\n    }\r\n    return /^-?[0-9]+$/.test(String(value));\r\n};\r\nvar integer = {\r\n    validate: validate$d\r\n};\n\nvar validate$e = function (value, _a) {\r\n    var other = _a.other;\r\n    return value === other;\r\n};\r\nvar params$9 = [\r\n    {\r\n        name: 'other'\r\n    }\r\n];\r\nvar is = {\r\n    validate: validate$e,\r\n    params: params$9\r\n};\n\nvar validate$f = function (value, _a) {\r\n    var other = _a.other;\r\n    return value !== other;\r\n};\r\nvar params$a = [\r\n    {\r\n        name: 'other'\r\n    }\r\n];\r\nvar is_not = {\r\n    validate: validate$f,\r\n    params: params$a\r\n};\n\nvar validate$g = function (value, _a) {\r\n    var length = _a.length;\r\n    if (isNullOrUndefined(value)) {\r\n        return false;\r\n    }\r\n    if (typeof value === 'number') {\r\n        value = String(value);\r\n    }\r\n    if (!value.length) {\r\n        value = toArray(value);\r\n    }\r\n    return value.length === length;\r\n};\r\nvar params$b = [\r\n    {\r\n        name: 'length',\r\n        cast: function (value) { return Number(value); }\r\n    }\r\n];\r\nvar length = {\r\n    validate: validate$g,\r\n    params: params$b\r\n};\n\nvar validate$h = function (value, _a) {\r\n    var length = _a.length;\r\n    if (isNullOrUndefined(value)) {\r\n        return length >= 0;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$h(val, { length: length }); });\r\n    }\r\n    return String(value).length <= length;\r\n};\r\nvar params$c = [\r\n    {\r\n        name: 'length',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar max = {\r\n    validate: validate$h,\r\n    params: params$c\r\n};\n\nvar validate$i = function (value, _a) {\r\n    var max = _a.max;\r\n    if (isNullOrUndefined(value) || value === '') {\r\n        return false;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.length > 0 && value.every(function (val) { return validate$i(val, { max: max }); });\r\n    }\r\n    return Number(value) <= max;\r\n};\r\nvar params$d = [\r\n    {\r\n        name: 'max',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar max_value = {\r\n    validate: validate$i,\r\n    params: params$d\r\n};\n\nvar validate$j = function (files, mimes) {\r\n    var regex = new RegExp(mimes.join('|').replace('*', '.+') + \"$\", 'i');\r\n    if (Array.isArray(files)) {\r\n        return files.every(function (file) { return regex.test(file.type); });\r\n    }\r\n    return regex.test(files.type);\r\n};\r\nvar mimes = {\r\n    validate: validate$j\r\n};\n\nvar validate$k = function (value, _a) {\r\n    var length = _a.length;\r\n    if (isNullOrUndefined(value)) {\r\n        return false;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$k(val, { length: length }); });\r\n    }\r\n    return String(value).length >= length;\r\n};\r\nvar params$e = [\r\n    {\r\n        name: 'length',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar min = {\r\n    validate: validate$k,\r\n    params: params$e\r\n};\n\nvar validate$l = function (value, _a) {\r\n    var min = _a.min;\r\n    if (isNullOrUndefined(value) || value === '') {\r\n        return false;\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return value.length > 0 && value.every(function (val) { return validate$l(val, { min: min }); });\r\n    }\r\n    return Number(value) >= min;\r\n};\r\nvar params$f = [\r\n    {\r\n        name: 'min',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar min_value = {\r\n    validate: validate$l,\r\n    params: params$f\r\n};\n\nvar ar = /^[]+$/;\r\nvar en = /^[0-9]+$/;\r\nvar validate$m = function (value) {\r\n    var testValue = function (val) {\r\n        var strValue = String(val);\r\n        return en.test(strValue) || ar.test(strValue);\r\n    };\r\n    if (Array.isArray(value)) {\r\n        return value.every(testValue);\r\n    }\r\n    return testValue(value);\r\n};\r\nvar numeric = {\r\n    validate: validate$m\r\n};\n\nvar validate$n = function (value, _a) {\r\n    var regex = _a.regex;\r\n    if (Array.isArray(value)) {\r\n        return value.every(function (val) { return validate$n(val, { regex: regex }); });\r\n    }\r\n    return regex.test(String(value));\r\n};\r\nvar params$g = [\r\n    {\r\n        name: 'regex',\r\n        cast: function (value) {\r\n            if (typeof value === 'string') {\r\n                return new RegExp(value);\r\n            }\r\n            return value;\r\n        }\r\n    }\r\n];\r\nvar regex = {\r\n    validate: validate$n,\r\n    params: params$g\r\n};\n\nvar validate$o = function (value, _a) {\r\n    var allowFalse = (_a === void 0 ? { allowFalse: true } : _a).allowFalse;\r\n    var result = {\r\n        valid: false,\r\n        required: true\r\n    };\r\n    if (isNullOrUndefined(value) || isEmptyArray(value)) {\r\n        return result;\r\n    }\r\n    // incase a field considers `false` as an empty value like checkboxes.\r\n    if (value === false && !allowFalse) {\r\n        return result;\r\n    }\r\n    result.valid = !!String(value).trim().length;\r\n    return result;\r\n};\r\nvar computesRequired = true;\r\nvar params$h = [\r\n    {\r\n        name: 'allowFalse',\r\n        default: true\r\n    }\r\n];\r\nvar required = {\r\n    validate: validate$o,\r\n    params: params$h,\r\n    computesRequired: computesRequired\r\n};\n\nvar testEmpty = function (value) {\r\n    return isEmptyArray(value) || includes([false, null, undefined], value) || !String(value).trim().length;\r\n};\r\nvar validate$p = function (value, _a) {\r\n    var target = _a.target, values = _a.values;\r\n    var required;\r\n    if (values && values.length) {\r\n        if (!Array.isArray(values) && typeof values === 'string') {\r\n            values = [values];\r\n        }\r\n        // eslint-disable-next-line\r\n        required = values.some(function (val) { return val == String(target).trim(); });\r\n    }\r\n    else {\r\n        required = !testEmpty(target);\r\n    }\r\n    if (!required) {\r\n        return {\r\n            valid: true,\r\n            required: required\r\n        };\r\n    }\r\n    return {\r\n        valid: !testEmpty(value),\r\n        required: required\r\n    };\r\n};\r\nvar params$i = [\r\n    {\r\n        name: 'target',\r\n        isTarget: true\r\n    },\r\n    {\r\n        name: 'values'\r\n    }\r\n];\r\nvar computesRequired$1 = true;\r\nvar required_if = {\r\n    validate: validate$p,\r\n    params: params$i,\r\n    computesRequired: computesRequired$1\r\n};\n\nvar validate$q = function (files, _a) {\r\n    var size = _a.size;\r\n    if (isNaN(size)) {\r\n        return false;\r\n    }\r\n    var nSize = size * 1024;\r\n    if (!Array.isArray(files)) {\r\n        return files.size <= nSize;\r\n    }\r\n    for (var i = 0; i < files.length; i++) {\r\n        if (files[i].size > nSize) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n};\r\nvar params$j = [\r\n    {\r\n        name: 'size',\r\n        cast: function (value) {\r\n            return Number(value);\r\n        }\r\n    }\r\n];\r\nvar size = {\r\n    validate: validate$q,\r\n    params: params$j\r\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvcnVsZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvcnVsZXMuanM/NGM5MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAgKiB2ZWUtdmFsaWRhdGUgdjMuMi41XG4gICogKGMpIDIwMjAgQWJkZWxyYWhtYW4gQXdhZFxuICAqIEBsaWNlbnNlIE1JVFxuICAqL1xuLyoqXHJcbiAqIFNvbWUgQWxwaGEgUmVnZXggaGVscGVycy5cclxuICogaHR0cHM6Ly9naXRodWIuY29tL2Nocmlzby92YWxpZGF0b3IuanMvYmxvYi9tYXN0ZXIvc3JjL2xpYi9hbHBoYS5qc1xyXG4gKi9cclxudmFyIGFscGhhID0ge1xyXG4gICAgZW46IC9eW0EtWl0qJC9pLFxyXG4gICAgY3M6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvV0qJC9pLFxyXG4gICAgZGE6IC9eW0EtWsOGw5jDhV0qJC9pLFxyXG4gICAgZGU6IC9eW0EtWsOEw5bDnMOfXSokL2ksXHJcbiAgICBlczogL15bQS1aw4HDicONw5HDk8Oaw5xdKiQvaSxcclxuICAgIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxyXG4gICAgaXQ6IC9eW0EtWlxceEMwLVxceEZGXSokL2ksXHJcbiAgICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXHJcbiAgICBubDogL15bQS1aw4nDi8OPw5PDlsOcXSokL2ksXHJcbiAgICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXHJcbiAgICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXHJcbiAgICBwdDogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcclxuICAgIHJ1OiAvXlvQkC3Qr9CBXSokL2ksXHJcbiAgICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcclxuICAgIHNyOiAvXltBLVrEjMSGxb3FoMSQXSokL2ksXHJcbiAgICBzdjogL15bQS1aw4XDhMOWXSokL2ksXHJcbiAgICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcclxuICAgIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXHJcbiAgICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXSokLyxcclxuICAgIGF6OiAvXltBLVrDh8aPxJ7EsMSxw5bFnsOcXSokL2lcclxufTtcclxudmFyIGFscGhhU3BhY2VzID0ge1xyXG4gICAgZW46IC9eW0EtWlxcc10qJC9pLFxyXG4gICAgY3M6IC9eW0EtWsOBxIzEjsOJxJrDjcWHw5PFmMWgxaTDmsWuw53FvVxcc10qJC9pLFxyXG4gICAgZGE6IC9eW0EtWsOGw5jDhVxcc10qJC9pLFxyXG4gICAgZGU6IC9eW0EtWsOEw5bDnMOfXFxzXSokL2ksXHJcbiAgICBlczogL15bQS1aw4HDicONw5HDk8Oaw5xcXHNdKiQvaSxcclxuICAgIGZyOiAvXltBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuFxcc10qJC9pLFxyXG4gICAgaXQ6IC9eW0EtWlxceEMwLVxceEZGXFxzXSokL2ksXHJcbiAgICBsdDogL15bQS1axITEjMSYxJbErsWgxbLFqsW9XFxzXSokL2ksXHJcbiAgICBubDogL15bQS1aw4nDi8OPw5PDlsOcXFxzXSokL2ksXHJcbiAgICBodTogL15bQS1aw4HDicONw5PDlsWQw5rDnMWwXFxzXSokL2ksXHJcbiAgICBwbDogL15bQS1axITEhsSYxZrFgcWDw5PFu8W5XFxzXSokL2ksXHJcbiAgICBwdDogL15bQS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xcXHNdKiQvaSxcclxuICAgIHJ1OiAvXlvQkC3Qr9CBXFxzXSokL2ksXHJcbiAgICBzazogL15bQS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1cXHNdKiQvaSxcclxuICAgIHNyOiAvXltBLVrEjMSGxb3FoMSQXFxzXSokL2ksXHJcbiAgICBzdjogL15bQS1aw4XDhMOWXFxzXSokL2ksXHJcbiAgICB0cjogL15bQS1aw4fEnsSwxLHDlsWew5xcXHNdKiQvaSxcclxuICAgIHVrOiAvXlvQkC3QqdCs0K7Qr9CE0IbQh9KQXFxzXSokL2ksXHJcbiAgICBhcjogL15b2KHYotij2KTYpdim2KfYqNip2KrYq9is2K3Yrtiv2LDYsdiy2LPYtNi12LbYt9i42LnYutmB2YLZg9mE2YXZhtmH2YjZidmK2YvZjNmN2Y7Zj9mQ2ZHZktmwXFxzXSokLyxcclxuICAgIGF6OiAvXltBLVrDh8aPxJ7EsMSxw5bFnsOcXFxzXSokL2lcclxufTtcclxudmFyIGFscGhhbnVtZXJpYyA9IHtcclxuICAgIGVuOiAvXlswLTlBLVpdKiQvaSxcclxuICAgIGNzOiAvXlswLTlBLVrDgcSMxI7DicSaw43Fh8OTxZjFoMWkw5rFrsOdxb1dKiQvaSxcclxuICAgIGRhOiAvXlswLTlBLVrDhsOYw4VdJC9pLFxyXG4gICAgZGU6IC9eWzAtOUEtWsOEw5bDnMOfXSokL2ksXHJcbiAgICBlczogL15bMC05QS1aw4HDicONw5HDk8Oaw5xdKiQvaSxcclxuICAgIGZyOiAvXlswLTlBLVrDgMOCw4bDh8OJw4jDisOLw4/DjsOUxZLDmcObw5zFuF0qJC9pLFxyXG4gICAgaXQ6IC9eWzAtOUEtWlxceEMwLVxceEZGXSokL2ksXHJcbiAgICBsdDogL15bMC05QS1axITEjMSYxJbErsWgxbLFqsW9XSokL2ksXHJcbiAgICBodTogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXSokL2ksXHJcbiAgICBubDogL15bMC05QS1aw4nDi8OPw5PDlsOcXSokL2ksXHJcbiAgICBwbDogL15bMC05QS1axITEhsSYxZrFgcWDw5PFu8W5XSokL2ksXHJcbiAgICBwdDogL15bMC05QS1aw4PDgcOAw4LDh8OJw4rDjcOVw5PDlMOaw5xdKiQvaSxcclxuICAgIHJ1OiAvXlswLTnQkC3Qr9CBXSokL2ksXHJcbiAgICBzazogL15bMC05QS1aw4HDhMSMxI7DicONxLnEvcWHw5PFlMWgxaTDmsOdxb1dKiQvaSxcclxuICAgIHNyOiAvXlswLTlBLVrEjMSGxb3FoMSQXSokL2ksXHJcbiAgICBzdjogL15bMC05QS1aw4XDhMOWXSokL2ksXHJcbiAgICB0cjogL15bMC05QS1aw4fEnsSwxLHDlsWew5xdKiQvaSxcclxuICAgIHVrOiAvXlswLTnQkC3QqdCs0K7Qr9CE0IbQh9KQXSokL2ksXHJcbiAgICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBdKiQvLFxyXG4gICAgYXo6IC9eWzAtOUEtWsOHxo/EnsSwxLHDlsWew5xdKiQvaVxyXG59O1xyXG52YXIgYWxwaGFEYXNoID0ge1xyXG4gICAgZW46IC9eWzAtOUEtWl8tXSokL2ksXHJcbiAgICBjczogL15bMC05QS1aw4HEjMSOw4nEmsONxYfDk8WYxaDFpMOaxa7DncW9Xy1dKiQvaSxcclxuICAgIGRhOiAvXlswLTlBLVrDhsOYw4VfLV0qJC9pLFxyXG4gICAgZGU6IC9eWzAtOUEtWsOEw5bDnMOfXy1dKiQvaSxcclxuICAgIGVzOiAvXlswLTlBLVrDgcOJw43DkcOTw5rDnF8tXSokL2ksXHJcbiAgICBmcjogL15bMC05QS1aw4DDgsOGw4fDicOIw4rDi8OPw47DlMWSw5nDm8OcxbhfLV0qJC9pLFxyXG4gICAgaXQ6IC9eWzAtOUEtWlxceEMwLVxceEZGXy1dKiQvaSxcclxuICAgIGx0OiAvXlswLTlBLVrEhMSMxJjElsSuxaDFssWqxb1fLV0qJC9pLFxyXG4gICAgbmw6IC9eWzAtOUEtWsOJw4vDj8OTw5bDnF8tXSokL2ksXHJcbiAgICBodTogL15bMC05QS1aw4HDicONw5PDlsWQw5rDnMWwXy1dKiQvaSxcclxuICAgIHBsOiAvXlswLTlBLVrEhMSGxJjFmsWBxYPDk8W7xblfLV0qJC9pLFxyXG4gICAgcHQ6IC9eWzAtOUEtWsODw4HDgMOCw4fDicOKw43DlcOTw5TDmsOcXy1dKiQvaSxcclxuICAgIHJ1OiAvXlswLTnQkC3Qr9CBXy1dKiQvaSxcclxuICAgIHNrOiAvXlswLTlBLVrDgcOExIzEjsOJw43EucS9xYfDk8WUxaDFpMOaw53FvV8tXSokL2ksXHJcbiAgICBzcjogL15bMC05QS1axIzEhsW9xaDEkF8tXSokL2ksXHJcbiAgICBzdjogL15bMC05QS1aw4XDhMOWXy1dKiQvaSxcclxuICAgIHRyOiAvXlswLTlBLVrDh8SexLDEscOWxZ7DnF8tXSokL2ksXHJcbiAgICB1azogL15bMC050JAt0KnQrNCu0K/QhNCG0IfSkF8tXSokL2ksXHJcbiAgICBhcjogL15b2aDZodmi2aPZpNml2abZp9mo2akwLTnYodii2KPYpNil2KbYp9io2KnYqtir2KzYrdiu2K/YsNix2LLYs9i02LXYtti32LjYudi62YHZgtmD2YTZhdmG2YfZiNmJ2YrZi9mM2Y3ZjtmP2ZDZkdmS2bBfLV0qJC8sXHJcbiAgICBhejogL15bMC05QS1aw4fGj8SexLDEscOWxZ7DnF8tXSokL2lcclxufTtcblxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5sb2NhbGUsIGxvY2FsZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlKHZhbCwgeyBsb2NhbGU6IGxvY2FsZSB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxyXG4gICAgaWYgKCFsb2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGEpLnNvbWUoZnVuY3Rpb24gKGxvYykgeyByZXR1cm4gYWxwaGFbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGFscGhhW2xvY2FsZV0gfHwgYWxwaGEuZW4pLnRlc3QodmFsdWUpO1xyXG59O1xyXG52YXIgcGFyYW1zID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdsb2NhbGUnXHJcbiAgICB9XHJcbl07XHJcbnZhciBhbHBoYSQxID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlLFxyXG4gICAgcGFyYW1zOiBwYXJhbXNcclxufTtcblxudmFyIHZhbGlkYXRlJDEgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmxvY2FsZSwgbG9jYWxlID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMSh2YWwsIHsgbG9jYWxlOiBsb2NhbGUgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgIGlmICghbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFscGhhRGFzaCkuc29tZShmdW5jdGlvbiAobG9jKSB7IHJldHVybiBhbHBoYURhc2hbbG9jXS50ZXN0KHZhbHVlKTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gKGFscGhhRGFzaFtsb2NhbGVdIHx8IGFscGhhRGFzaC5lbikudGVzdCh2YWx1ZSk7XHJcbn07XHJcbnZhciBwYXJhbXMkMSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbG9jYWxlJ1xyXG4gICAgfVxyXG5dO1xyXG52YXIgYWxwaGFfZGFzaCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQxLFxyXG4gICAgcGFyYW1zOiBwYXJhbXMkMVxyXG59O1xuXG52YXIgdmFsaWRhdGUkMiA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciBfYiA9IChfYSA9PT0gdm9pZCAwID8ge30gOiBfYSkubG9jYWxlLCBsb2NhbGUgPSBfYiA9PT0gdm9pZCAwID8gJycgOiBfYjtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSQyKHZhbCwgeyBsb2NhbGU6IGxvY2FsZSB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICAvLyBNYXRjaCBhdCBsZWFzdCBvbmUgbG9jYWxlLlxyXG4gICAgaWYgKCFsb2NhbGUpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoYWxwaGFudW1lcmljKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhbnVtZXJpY1tsb2NdLnRlc3QodmFsdWUpOyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAoYWxwaGFudW1lcmljW2xvY2FsZV0gfHwgYWxwaGFudW1lcmljLmVuKS50ZXN0KHZhbHVlKTtcclxufTtcclxudmFyIHBhcmFtcyQyID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdsb2NhbGUnXHJcbiAgICB9XHJcbl07XHJcbnZhciBhbHBoYV9udW0gPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkMixcclxuICAgIHBhcmFtczogcGFyYW1zJDJcclxufTtcblxudmFyIHZhbGlkYXRlJDMgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLmxvY2FsZSwgbG9jYWxlID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkMyh2YWwsIHsgbG9jYWxlOiBsb2NhbGUgfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgLy8gTWF0Y2ggYXQgbGVhc3Qgb25lIGxvY2FsZS5cclxuICAgIGlmICghbG9jYWxlKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGFscGhhU3BhY2VzKS5zb21lKGZ1bmN0aW9uIChsb2MpIHsgcmV0dXJuIGFscGhhU3BhY2VzW2xvY10udGVzdCh2YWx1ZSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChhbHBoYVNwYWNlc1tsb2NhbGVdIHx8IGFscGhhU3BhY2VzLmVuKS50ZXN0KHZhbHVlKTtcclxufTtcclxudmFyIHBhcmFtcyQzID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdsb2NhbGUnXHJcbiAgICB9XHJcbl07XHJcbnZhciBhbHBoYV9zcGFjZXMgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkMyxcclxuICAgIHBhcmFtczogcGFyYW1zJDNcclxufTtcblxudmFyIHZhbGlkYXRlJDQgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgbWluID0gX2IubWluLCBtYXggPSBfYi5tYXg7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gISF2YWxpZGF0ZSQ0KHZhbCwgeyBtaW46IG1pbiwgbWF4OiBtYXggfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE51bWJlcihtaW4pIDw9IHZhbHVlICYmIE51bWJlcihtYXgpID49IHZhbHVlO1xyXG59O1xyXG52YXIgcGFyYW1zJDQgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ21pbidcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ21heCdcclxuICAgIH1cclxuXTtcclxudmFyIGJldHdlZW4gPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkNCxcclxuICAgIHBhcmFtczogcGFyYW1zJDRcclxufTtcblxudmFyIHZhbGlkYXRlJDUgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gX2EudGFyZ2V0O1xyXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkgPT09IFN0cmluZyh0YXJnZXQpO1xyXG59O1xyXG52YXIgcGFyYW1zJDUgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ3RhcmdldCcsXHJcbiAgICAgICAgaXNUYXJnZXQ6IHRydWVcclxuICAgIH1cclxuXTtcclxudmFyIGNvbmZpcm1lZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ1LFxyXG4gICAgcGFyYW1zOiBwYXJhbXMkNVxyXG59O1xuXG52YXIgdmFsaWRhdGUkNiA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciBsZW5ndGggPSBfYS5sZW5ndGg7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkNih2YWwsIHsgbGVuZ3RoOiBsZW5ndGggfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgdmFyIHN0clZhbCA9IFN0cmluZyh2YWx1ZSk7XHJcbiAgICByZXR1cm4gL15bMC05XSokLy50ZXN0KHN0clZhbCkgJiYgc3RyVmFsLmxlbmd0aCA9PT0gbGVuZ3RoO1xyXG59O1xyXG52YXIgcGFyYW1zJDYgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2xlbmd0aCcsXHJcbiAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXTtcclxudmFyIGRpZ2l0cyA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ2LFxyXG4gICAgcGFyYW1zOiBwYXJhbXMkNlxyXG59O1xuXG52YXIgdmFsaWRhdGVJbWFnZSA9IGZ1bmN0aW9uIChmaWxlLCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICB2YXIgVVJMID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgaW1hZ2Uub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoZmFsc2UpOyB9O1xyXG4gICAgICAgIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoaW1hZ2Uud2lkdGggPT09IHdpZHRoICYmIGltYWdlLmhlaWdodCA9PT0gaGVpZ2h0KTsgfTtcclxuICAgICAgICBpbWFnZS5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciB2YWxpZGF0ZSQ3ID0gZnVuY3Rpb24gKGZpbGVzLCBfYSkge1xyXG4gICAgdmFyIHdpZHRoID0gX2Eud2lkdGgsIGhlaWdodCA9IF9hLmhlaWdodDtcclxuICAgIHZhciBsaXN0ID0gW107XHJcbiAgICBmaWxlcyA9IEFycmF5LmlzQXJyYXkoZmlsZXMpID8gZmlsZXMgOiBbZmlsZXNdO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIC8vIGlmIGZpbGUgaXMgbm90IGFuIGltYWdlLCByZWplY3QuXHJcbiAgICAgICAgaWYgKCEvXFwuKGpwZ3xzdmd8anBlZ3xwbmd8Ym1wfGdpZikkL2kudGVzdChmaWxlc1tpXS5uYW1lKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGlzdC5wdXNoKGZpbGVzW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBQcm9taXNlLmFsbChsaXN0Lm1hcChmdW5jdGlvbiAoZmlsZSkgeyByZXR1cm4gdmFsaWRhdGVJbWFnZShmaWxlLCB3aWR0aCwgaGVpZ2h0KTsgfSkpLnRoZW4oZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZXMuZXZlcnkoZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHY7IH0pO1xyXG4gICAgfSk7XHJcbn07XHJcbnZhciBwYXJhbXMkNyA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnd2lkdGgnLFxyXG4gICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdoZWlnaHQnLFxyXG4gICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbl07XHJcbnZhciBkaW1lbnNpb25zID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJDcsXHJcbiAgICBwYXJhbXM6IHBhcmFtcyQ3XHJcbn07XG5cbnZhciB2YWxpZGF0ZSQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIG11bHRpcGxlID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5tdWx0aXBsZTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgdmFyIHJlID0gL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFxdKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcclxuICAgIGlmIChtdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICB2YWx1ZSA9IFN0cmluZyh2YWx1ZSlcclxuICAgICAgICAgICAgLnNwbGl0KCcsJylcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZW1haWxTdHIpIHsgcmV0dXJuIGVtYWlsU3RyLnRyaW0oKTsgfSk7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gcmUudGVzdChTdHJpbmcodmFsKSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlLnRlc3QoU3RyaW5nKHZhbHVlKSk7XHJcbn07XHJcbnZhciBwYXJhbXMkOCA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbXVsdGlwbGUnLFxyXG4gICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICB9XHJcbl07XHJcbnZhciBlbWFpbCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSQ4LFxyXG4gICAgcGFyYW1zOiBwYXJhbXMkOFxyXG59O1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gaXNFbXB0eUFycmF5KGFycikge1xyXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJyKSAmJiBhcnIubGVuZ3RoID09PSAwO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2FsbGFibGUoZm4pIHtcclxuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XHJcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgaXRlbSkge1xyXG4gICAgcmV0dXJuIGNvbGxlY3Rpb24uaW5kZXhPZihpdGVtKSAhPT0gLTE7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnRzIGFuIGFycmF5LWxpa2Ugb2JqZWN0IHRvIGFycmF5LCBwcm92aWRlcyBhIHNpbXBsZSBwb2x5ZmlsbCBmb3IgQXJyYXkuZnJvbVxyXG4gKi9cclxuZnVuY3Rpb24gdG9BcnJheShhcnJheUxpa2UpIHtcclxuICAgIGlmIChpc0NhbGxhYmxlKEFycmF5LmZyb20pKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyYXlMaWtlKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICByZXR1cm4gX2NvcHlBcnJheShhcnJheUxpa2UpO1xyXG59XHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmZ1bmN0aW9uIF9jb3B5QXJyYXkoYXJyYXlMaWtlKSB7XHJcbiAgICB2YXIgYXJyYXkgPSBbXTtcclxuICAgIHZhciBsZW5ndGggPSBhcnJheUxpa2UubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFycmF5LnB1c2goYXJyYXlMaWtlW2ldKTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheTtcclxufVxuXG52YXIgdmFsaWRhdGUkOSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJDkodmFsLCBvcHRpb25zKTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG9BcnJheShvcHRpb25zKS5zb21lKGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgcmV0dXJuIGl0ZW0gPT0gdmFsdWU7XHJcbiAgICB9KTtcclxufTtcclxudmFyIG9uZU9mID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJDlcclxufTtcblxudmFyIHZhbGlkYXRlJGEgPSBmdW5jdGlvbiAodmFsdWUsIGFyZ3MpIHtcclxuICAgIHJldHVybiAhdmFsaWRhdGUkOSh2YWx1ZSwgYXJncyk7XHJcbn07XHJcbnZhciBleGNsdWRlZCA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRhXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRiID0gZnVuY3Rpb24gKGZpbGVzLCBleHRlbnNpb25zKSB7XHJcbiAgICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiLihcIiArIGV4dGVuc2lvbnMuam9pbignfCcpICsgXCIpJFwiLCAnaScpO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiByZWdleC50ZXN0KGZpbGUubmFtZSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZXMubmFtZSk7XHJcbn07XHJcbnZhciBleHQgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkYlxyXG59O1xuXG52YXIgdmFsaWRhdGUkYyA9IGZ1bmN0aW9uIChmaWxlcykge1xyXG4gICAgdmFyIHJlZ2V4ID0gL1xcLihqcGd8c3ZnfGpwZWd8cG5nfGJtcHxnaWYpJC9pO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGVzLmV2ZXJ5KGZ1bmN0aW9uIChmaWxlKSB7IHJldHVybiByZWdleC50ZXN0KGZpbGUubmFtZSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZXMubmFtZSk7XHJcbn07XHJcbnZhciBpbWFnZSA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRjXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRkID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gL14tP1swLTldKyQvLnRlc3QoU3RyaW5nKHZhbCkpOyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiAvXi0/WzAtOV0rJC8udGVzdChTdHJpbmcodmFsdWUpKTtcclxufTtcclxudmFyIGludGVnZXIgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkZFxyXG59O1xuXG52YXIgdmFsaWRhdGUkZSA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciBvdGhlciA9IF9hLm90aGVyO1xyXG4gICAgcmV0dXJuIHZhbHVlID09PSBvdGhlcjtcclxufTtcclxudmFyIHBhcmFtcyQ5ID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdvdGhlcidcclxuICAgIH1cclxuXTtcclxudmFyIGlzID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGUsXHJcbiAgICBwYXJhbXM6IHBhcmFtcyQ5XHJcbn07XG5cbnZhciB2YWxpZGF0ZSRmID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIG90aGVyID0gX2Eub3RoZXI7XHJcbiAgICByZXR1cm4gdmFsdWUgIT09IG90aGVyO1xyXG59O1xyXG52YXIgcGFyYW1zJGEgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ290aGVyJ1xyXG4gICAgfVxyXG5dO1xyXG52YXIgaXNfbm90ID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGYsXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRhXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRnID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIGxlbmd0aCA9IF9hLmxlbmd0aDtcclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHZhbHVlID0gU3RyaW5nKHZhbHVlKTtcclxuICAgIH1cclxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XHJcbiAgICAgICAgdmFsdWUgPSB0b0FycmF5KHZhbHVlKTtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IGxlbmd0aDtcclxufTtcclxudmFyIHBhcmFtcyRiID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdsZW5ndGgnLFxyXG4gICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gTnVtYmVyKHZhbHVlKTsgfVxyXG4gICAgfVxyXG5dO1xyXG52YXIgbGVuZ3RoID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGcsXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRiXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRoID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIGxlbmd0aCA9IF9hLmxlbmd0aDtcclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gbGVuZ3RoID49IDA7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUuZXZlcnkoZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdmFsaWRhdGUkaCh2YWwsIHsgbGVuZ3RoOiBsZW5ndGggfSk7IH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFN0cmluZyh2YWx1ZSkubGVuZ3RoIDw9IGxlbmd0aDtcclxufTtcclxudmFyIHBhcmFtcyRjID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdsZW5ndGgnLFxyXG4gICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbl07XHJcbnZhciBtYXggPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkaCxcclxuICAgIHBhcmFtczogcGFyYW1zJGNcclxufTtcblxudmFyIHZhbGlkYXRlJGkgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgbWF4ID0gX2EubWF4O1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID4gMCAmJiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRpKHZhbCwgeyBtYXg6IG1heCB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlKSA8PSBtYXg7XHJcbn07XHJcbnZhciBwYXJhbXMkZCA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnbWF4JyxcclxuICAgICAgICBjYXN0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5dO1xyXG52YXIgbWF4X3ZhbHVlID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGksXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRkXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRqID0gZnVuY3Rpb24gKGZpbGVzLCBtaW1lcykge1xyXG4gICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChtaW1lcy5qb2luKCd8JykucmVwbGFjZSgnKicsICcuKycpICsgXCIkXCIsICdpJyk7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmaWxlcykpIHtcclxuICAgICAgICByZXR1cm4gZmlsZXMuZXZlcnkoZnVuY3Rpb24gKGZpbGUpIHsgcmV0dXJuIHJlZ2V4LnRlc3QoZmlsZS50eXBlKTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnZXgudGVzdChmaWxlcy50eXBlKTtcclxufTtcclxudmFyIG1pbWVzID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJGpcclxufTtcblxudmFyIHZhbGlkYXRlJGsgPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XHJcbiAgICB2YXIgbGVuZ3RoID0gX2EubGVuZ3RoO1xyXG4gICAgaWYgKGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5ldmVyeShmdW5jdGlvbiAodmFsKSB7IHJldHVybiB2YWxpZGF0ZSRrKHZhbCwgeyBsZW5ndGg6IGxlbmd0aCB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU3RyaW5nKHZhbHVlKS5sZW5ndGggPj0gbGVuZ3RoO1xyXG59O1xyXG52YXIgcGFyYW1zJGUgPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2xlbmd0aCcsXHJcbiAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXTtcclxudmFyIG1pbiA9IHtcclxuICAgIHZhbGlkYXRlOiB2YWxpZGF0ZSRrLFxyXG4gICAgcGFyYW1zOiBwYXJhbXMkZVxyXG59O1xuXG52YXIgdmFsaWRhdGUkbCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciBtaW4gPSBfYS5taW47XHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJykge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPiAwICYmIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJGwodmFsLCB7IG1pbjogbWluIH0pOyB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBOdW1iZXIodmFsdWUpID49IG1pbjtcclxufTtcclxudmFyIHBhcmFtcyRmID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdtaW4nLFxyXG4gICAgICAgIGNhc3Q6IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbl07XHJcbnZhciBtaW5fdmFsdWUgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkbCxcclxuICAgIHBhcmFtczogcGFyYW1zJGZcclxufTtcblxudmFyIGFyID0gL15b2aDZodmi2aPZpNml2abZp9mo2aldKyQvO1xyXG52YXIgZW4gPSAvXlswLTldKyQvO1xyXG52YXIgdmFsaWRhdGUkbSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgdmFyIHRlc3RWYWx1ZSA9IGZ1bmN0aW9uICh2YWwpIHtcclxuICAgICAgICB2YXIgc3RyVmFsdWUgPSBTdHJpbmcodmFsKTtcclxuICAgICAgICByZXR1cm4gZW4udGVzdChzdHJWYWx1ZSkgfHwgYXIudGVzdChzdHJWYWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KHRlc3RWYWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGVzdFZhbHVlKHZhbHVlKTtcclxufTtcclxudmFyIG51bWVyaWMgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkbVxyXG59O1xuXG52YXIgdmFsaWRhdGUkbiA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciByZWdleCA9IF9hLnJlZ2V4O1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLmV2ZXJ5KGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbGlkYXRlJG4odmFsLCB7IHJlZ2V4OiByZWdleCB9KTsgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVnZXgudGVzdChTdHJpbmcodmFsdWUpKTtcclxufTtcclxudmFyIHBhcmFtcyRnID0gW1xyXG4gICAge1xyXG4gICAgICAgIG5hbWU6ICdyZWdleCcsXHJcbiAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cCh2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXTtcclxudmFyIHJlZ2V4ID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJG4sXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRnXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRvID0gZnVuY3Rpb24gKHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIGFsbG93RmFsc2UgPSAoX2EgPT09IHZvaWQgMCA/IHsgYWxsb3dGYWxzZTogdHJ1ZSB9IDogX2EpLmFsbG93RmFsc2U7XHJcbiAgICB2YXIgcmVzdWx0ID0ge1xyXG4gICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICByZXF1aXJlZDogdHJ1ZVxyXG4gICAgfTtcclxuICAgIGlmIChpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkgfHwgaXNFbXB0eUFycmF5KHZhbHVlKSkge1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvLyBpbmNhc2UgYSBmaWVsZCBjb25zaWRlcnMgYGZhbHNlYCBhcyBhbiBlbXB0eSB2YWx1ZSBsaWtlIGNoZWNrYm94ZXMuXHJcbiAgICBpZiAodmFsdWUgPT09IGZhbHNlICYmICFhbGxvd0ZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJlc3VsdC52YWxpZCA9ICEhU3RyaW5nKHZhbHVlKS50cmltKCkubGVuZ3RoO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufTtcclxudmFyIGNvbXB1dGVzUmVxdWlyZWQgPSB0cnVlO1xyXG52YXIgcGFyYW1zJGggPSBbXHJcbiAgICB7XHJcbiAgICAgICAgbmFtZTogJ2FsbG93RmFsc2UnLFxyXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcclxuICAgIH1cclxuXTtcclxudmFyIHJlcXVpcmVkID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJG8sXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRoLFxyXG4gICAgY29tcHV0ZXNSZXF1aXJlZDogY29tcHV0ZXNSZXF1aXJlZFxyXG59O1xuXG52YXIgdGVzdEVtcHR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNFbXB0eUFycmF5KHZhbHVlKSB8fCBpbmNsdWRlcyhbZmFsc2UsIG51bGwsIHVuZGVmaW5lZF0sIHZhbHVlKSB8fCAhU3RyaW5nKHZhbHVlKS50cmltKCkubGVuZ3RoO1xyXG59O1xyXG52YXIgdmFsaWRhdGUkcCA9IGZ1bmN0aW9uICh2YWx1ZSwgX2EpIHtcclxuICAgIHZhciB0YXJnZXQgPSBfYS50YXJnZXQsIHZhbHVlcyA9IF9hLnZhbHVlcztcclxuICAgIHZhciByZXF1aXJlZDtcclxuICAgIGlmICh2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZXMpICYmIHR5cGVvZiB2YWx1ZXMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlcyA9IFt2YWx1ZXNdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICByZXF1aXJlZCA9IHZhbHVlcy5zb21lKGZ1bmN0aW9uICh2YWwpIHsgcmV0dXJuIHZhbCA9PSBTdHJpbmcodGFyZ2V0KS50cmltKCk7IH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmVxdWlyZWQgPSAhdGVzdEVtcHR5KHRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBpZiAoIXJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHJlcXVpcmVkOiByZXF1aXJlZFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHZhbGlkOiAhdGVzdEVtcHR5KHZhbHVlKSxcclxuICAgICAgICByZXF1aXJlZDogcmVxdWlyZWRcclxuICAgIH07XHJcbn07XHJcbnZhciBwYXJhbXMkaSA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAndGFyZ2V0JyxcclxuICAgICAgICBpc1RhcmdldDogdHJ1ZVxyXG4gICAgfSxcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAndmFsdWVzJ1xyXG4gICAgfVxyXG5dO1xyXG52YXIgY29tcHV0ZXNSZXF1aXJlZCQxID0gdHJ1ZTtcclxudmFyIHJlcXVpcmVkX2lmID0ge1xyXG4gICAgdmFsaWRhdGU6IHZhbGlkYXRlJHAsXHJcbiAgICBwYXJhbXM6IHBhcmFtcyRpLFxyXG4gICAgY29tcHV0ZXNSZXF1aXJlZDogY29tcHV0ZXNSZXF1aXJlZCQxXHJcbn07XG5cbnZhciB2YWxpZGF0ZSRxID0gZnVuY3Rpb24gKGZpbGVzLCBfYSkge1xyXG4gICAgdmFyIHNpemUgPSBfYS5zaXplO1xyXG4gICAgaWYgKGlzTmFOKHNpemUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIG5TaXplID0gc2l6ZSAqIDEwMjQ7XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbGVzLnNpemUgPD0gblNpemU7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGZpbGVzW2ldLnNpemUgPiBuU2l6ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XHJcbnZhciBwYXJhbXMkaiA9IFtcclxuICAgIHtcclxuICAgICAgICBuYW1lOiAnc2l6ZScsXHJcbiAgICAgICAgY2FzdDogZnVuY3Rpb24gKHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXTtcclxudmFyIHNpemUgPSB7XHJcbiAgICB2YWxpZGF0ZTogdmFsaWRhdGUkcSxcclxuICAgIHBhcmFtczogcGFyYW1zJGpcclxufTtcblxuZXhwb3J0IHsgYWxwaGEkMSBhcyBhbHBoYSwgYWxwaGFfZGFzaCwgYWxwaGFfbnVtLCBhbHBoYV9zcGFjZXMsIGJldHdlZW4sIGNvbmZpcm1lZCwgZGlnaXRzLCBkaW1lbnNpb25zLCBlbWFpbCwgZXhjbHVkZWQsIGV4dCwgaW1hZ2UsIGludGVnZXIsIGlzLCBpc19ub3QsIGxlbmd0aCwgbWF4LCBtYXhfdmFsdWUsIG1pbWVzLCBtaW4sIG1pbl92YWx1ZSwgbnVtZXJpYywgb25lT2YsIHJlZ2V4LCByZXF1aXJlZCwgcmVxdWlyZWRfaWYsIHNpemUgfTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vee-validate/dist/rules.js\n");

/***/ }),

/***/ "./node_modules/vee-validate/dist/vee-validate.esm.js":
/*!************************************************************!*\
  !*** ./node_modules/vee-validate/dist/vee-validate.esm.js ***!
  \************************************************************/
/*! exports provided: ValidationObserver, ValidationProvider, configure, extend, localeChanged, localize, normalizeRules, setInteractionMode, validate, version, withValidation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationObserver\", function() { return ValidationObserver; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ValidationProvider\", function() { return ValidationProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"configure\", function() { return configure; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"extend\", function() { return extend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localeChanged\", function() { return localeChanged; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"localize\", function() { return localize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalizeRules\", function() { return normalizeRules; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setInteractionMode\", function() { return setInteractionMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validate\", function() { return validate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"version\", function() { return version; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"withValidation\", function() { return withValidation; });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm.js\");\n/**\n  * vee-validate v3.2.5\n  * (c) 2020 Abdelrahman Awad\n  * @license MIT\n  */\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\n\nfunction isNaN(value) {\r\n    // NaN is the one value that does not equal itself.\r\n    // eslint-disable-next-line\r\n    return value !== value;\r\n}\r\nfunction isNullOrUndefined(value) {\r\n    return value === null || value === undefined;\r\n}\r\nfunction isEmptyArray(arr) {\r\n    return Array.isArray(arr) && arr.length === 0;\r\n}\r\nvar isObject = function (obj) {\r\n    return obj !== null && obj && typeof obj === 'object' && !Array.isArray(obj);\r\n};\r\n/**\r\n * Shallow object comparison.\r\n */\r\nfunction isEqual(lhs, rhs) {\r\n    if (lhs instanceof RegExp && rhs instanceof RegExp) {\r\n        return isEqual(lhs.source, rhs.source) && isEqual(lhs.flags, rhs.flags);\r\n    }\r\n    if (Array.isArray(lhs) && Array.isArray(rhs)) {\r\n        if (lhs.length !== rhs.length)\r\n            return false;\r\n        for (var i = 0; i < lhs.length; i++) {\r\n            if (!isEqual(lhs[i], rhs[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    // if both are objects, compare each key recursively.\r\n    if (isObject(lhs) && isObject(rhs)) {\r\n        return (Object.keys(lhs).every(function (key) {\r\n            return isEqual(lhs[key], rhs[key]);\r\n        }) &&\r\n            Object.keys(rhs).every(function (key) {\r\n                return isEqual(lhs[key], rhs[key]);\r\n            }));\r\n    }\r\n    if (isNaN(lhs) && isNaN(rhs)) {\r\n        return true;\r\n    }\r\n    return lhs === rhs;\r\n}\r\n// Checks if a given value is not an empty string or null or undefined.\r\nfunction isSpecified(val) {\r\n    if (val === '') {\r\n        return false;\r\n    }\r\n    return !isNullOrUndefined(val);\r\n}\r\nfunction isCallable(fn) {\r\n    return typeof fn === 'function';\r\n}\r\nfunction isLocator(value) {\r\n    return isCallable(value) && !!value.__locatorRef;\r\n}\n\nfunction findIndex(arrayLike, predicate) {\r\n    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\r\n    if (isCallable(array.findIndex)) {\r\n        return array.findIndex(predicate);\r\n    }\r\n    /* istanbul ignore next */\r\n    for (var i = 0; i < array.length; i++) {\r\n        if (predicate(array[i], i)) {\r\n            return i;\r\n        }\r\n    }\r\n    /* istanbul ignore next */\r\n    return -1;\r\n}\r\n/**\r\n * finds the first element that satisfies the predicate callback, polyfills array.find\r\n */\r\nfunction find(arrayLike, predicate) {\r\n    var array = Array.isArray(arrayLike) ? arrayLike : toArray(arrayLike);\r\n    var idx = findIndex(array, predicate);\r\n    return idx === -1 ? undefined : array[idx];\r\n}\r\nfunction includes(collection, item) {\r\n    return collection.indexOf(item) !== -1;\r\n}\r\n/**\r\n * Converts an array-like object to array, provides a simple polyfill for Array.from\r\n */\r\nfunction toArray(arrayLike) {\r\n    if (isCallable(Array.from)) {\r\n        return Array.from(arrayLike);\r\n    }\r\n    /* istanbul ignore next */\r\n    return _copyArray(arrayLike);\r\n}\r\n/* istanbul ignore next */\r\nfunction _copyArray(arrayLike) {\r\n    var array = [];\r\n    var length = arrayLike.length;\r\n    for (var i = 0; i < length; i++) {\r\n        array.push(arrayLike[i]);\r\n    }\r\n    return array;\r\n}\r\nfunction values(obj) {\r\n    if (isCallable(Object.values)) {\r\n        return Object.values(obj);\r\n    }\r\n    // fallback to keys()\r\n    /* istanbul ignore next */\r\n    return Object.keys(obj).map(function (k) { return obj[k]; });\r\n}\r\nfunction merge(target, source) {\r\n    Object.keys(source).forEach(function (key) {\r\n        if (isObject(source[key])) {\r\n            if (!target[key]) {\r\n                target[key] = {};\r\n            }\r\n            merge(target[key], source[key]);\r\n            return;\r\n        }\r\n        target[key] = source[key];\r\n    });\r\n    return target;\r\n}\n\nfunction createFlags() {\r\n    return {\r\n        untouched: true,\r\n        touched: false,\r\n        dirty: false,\r\n        pristine: true,\r\n        valid: false,\r\n        invalid: false,\r\n        validated: false,\r\n        pending: false,\r\n        required: false,\r\n        changed: false,\r\n        passed: false,\r\n        failed: false\r\n    };\r\n}\n\nfunction identity(x) {\r\n    return x;\r\n}\r\nfunction debounce(fn, wait, token) {\r\n    if (wait === void 0) { wait = 0; }\r\n    if (token === void 0) { token = { cancelled: false }; }\r\n    if (wait === 0) {\r\n        return fn;\r\n    }\r\n    var timeout;\r\n    return function () {\r\n        var args = [];\r\n        for (var _i = 0; _i < arguments.length; _i++) {\r\n            args[_i] = arguments[_i];\r\n        }\r\n        var later = function () {\r\n            timeout = undefined;\r\n            // check if the fn call was cancelled.\r\n            if (!token.cancelled)\r\n                fn.apply(void 0, args);\r\n        };\r\n        // because we might want to use Node.js setTimout for SSR.\r\n        clearTimeout(timeout);\r\n        timeout = setTimeout(later, wait);\r\n    };\r\n}\n\n/**\r\n * Emits a warning to the console\r\n */\r\nfunction warn(message) {\r\n    console.warn(\"[vee-validate] \" + message);\r\n}\r\n/**\r\n * Replaces placeholder values in a string with their actual values\r\n */\r\nfunction interpolate(template, values) {\r\n    return template.replace(/{([^}]+)}/g, function (_, p) {\r\n        return p in values ? values[p] : \"{\" + p + \"}\";\r\n    });\r\n}\n\nvar RULES = {};\r\nfunction normalizeSchema(schema) {\r\n    var _a;\r\n    if ((_a = schema.params) === null || _a === void 0 ? void 0 : _a.length) {\r\n        schema.params = schema.params.map(function (param) {\r\n            if (typeof param === 'string') {\r\n                return { name: param };\r\n            }\r\n            return param;\r\n        });\r\n    }\r\n    return schema;\r\n}\r\nvar RuleContainer = /** @class */ (function () {\r\n    function RuleContainer() {\r\n    }\r\n    RuleContainer.extend = function (name, schema) {\r\n        // if rule already exists, overwrite it.\r\n        var rule = normalizeSchema(schema);\r\n        if (RULES[name]) {\r\n            RULES[name] = merge(RULES[name], schema);\r\n            return;\r\n        }\r\n        RULES[name] = __assign({ lazy: false, computesRequired: false }, rule);\r\n    };\r\n    RuleContainer.isLazy = function (name) {\r\n        var _a;\r\n        return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.lazy);\r\n    };\r\n    RuleContainer.isRequireRule = function (name) {\r\n        var _a;\r\n        return !!((_a = RULES[name]) === null || _a === void 0 ? void 0 : _a.computesRequired);\r\n    };\r\n    RuleContainer.getRuleDefinition = function (ruleName) {\r\n        return RULES[ruleName];\r\n    };\r\n    return RuleContainer;\r\n}());\r\n/**\r\n * Adds a custom validator to the list of validation rules.\r\n */\r\nfunction extend(name, schema) {\r\n    // makes sure new rules are properly formatted.\r\n    guardExtend(name, schema);\r\n    // Full schema object.\r\n    if (typeof schema === 'object') {\r\n        RuleContainer.extend(name, schema);\r\n        return;\r\n    }\r\n    RuleContainer.extend(name, {\r\n        validate: schema\r\n    });\r\n}\r\n/**\r\n * Guards from extension violations.\r\n */\r\nfunction guardExtend(name, validator) {\r\n    if (isCallable(validator)) {\r\n        return;\r\n    }\r\n    if (isCallable(validator.validate)) {\r\n        return;\r\n    }\r\n    if (RuleContainer.getRuleDefinition(name)) {\r\n        return;\r\n    }\r\n    throw new Error(\"Extension Error: The validator '\" + name + \"' must be a function or have a 'validate' method.\");\r\n}\n\nvar DEFAULT_CONFIG = {\r\n    defaultMessage: \"{_field_} is not valid.\",\r\n    skipOptional: true,\r\n    classes: {\r\n        touched: 'touched',\r\n        untouched: 'untouched',\r\n        valid: 'valid',\r\n        invalid: 'invalid',\r\n        pristine: 'pristine',\r\n        dirty: 'dirty' // control has been interacted with\r\n    },\r\n    bails: true,\r\n    mode: 'aggressive',\r\n    useConstraintAttrs: true\r\n};\r\nvar currentConfig = __assign({}, DEFAULT_CONFIG);\r\nvar getConfig = function () { return currentConfig; };\r\nvar setConfig = function (newConf) {\r\n    currentConfig = __assign(__assign({}, currentConfig), newConf);\r\n};\r\nvar configure = function (cfg) {\r\n    setConfig(cfg);\r\n};\n\n/**\r\n * Normalizes the given rules expression.\r\n */\r\nfunction normalizeRules(rules) {\r\n    // if falsy value return an empty object.\r\n    var acc = {};\r\n    Object.defineProperty(acc, '_$$isNormalized', {\r\n        value: true,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false\r\n    });\r\n    if (!rules) {\r\n        return acc;\r\n    }\r\n    // Object is already normalized, skip.\r\n    if (isObject(rules) && rules._$$isNormalized) {\r\n        return rules;\r\n    }\r\n    if (isObject(rules)) {\r\n        return Object.keys(rules).reduce(function (prev, curr) {\r\n            var params = [];\r\n            if (rules[curr] === true) {\r\n                params = [];\r\n            }\r\n            else if (Array.isArray(rules[curr])) {\r\n                params = rules[curr];\r\n            }\r\n            else if (isObject(rules[curr])) {\r\n                params = rules[curr];\r\n            }\r\n            else {\r\n                params = [rules[curr]];\r\n            }\r\n            if (rules[curr] !== false) {\r\n                prev[curr] = buildParams(curr, params);\r\n            }\r\n            return prev;\r\n        }, acc);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (typeof rules !== 'string') {\r\n        warn('rules must be either a string or an object.');\r\n        return acc;\r\n    }\r\n    return rules.split('|').reduce(function (prev, rule) {\r\n        var parsedRule = parseRule(rule);\r\n        if (!parsedRule.name) {\r\n            return prev;\r\n        }\r\n        prev[parsedRule.name] = buildParams(parsedRule.name, parsedRule.params);\r\n        return prev;\r\n    }, acc);\r\n}\r\nfunction buildParams(ruleName, provided) {\r\n    var ruleSchema = RuleContainer.getRuleDefinition(ruleName);\r\n    if (!ruleSchema) {\r\n        return provided;\r\n    }\r\n    var params = {};\r\n    if (!ruleSchema.params && !Array.isArray(provided)) {\r\n        throw new Error('You provided an object params to a rule that has no defined schema.');\r\n    }\r\n    // Rule probably uses an array for their args, keep it as is.\r\n    if (Array.isArray(provided) && !ruleSchema.params) {\r\n        return provided;\r\n    }\r\n    var definedParams;\r\n    // collect the params schema.\r\n    if (!ruleSchema.params || (ruleSchema.params.length < provided.length && Array.isArray(provided))) {\r\n        var lastDefinedParam_1;\r\n        // collect any additional parameters in the last item.\r\n        definedParams = provided.map(function (_, idx) {\r\n            var _a;\r\n            var param = (_a = ruleSchema.params) === null || _a === void 0 ? void 0 : _a[idx];\r\n            lastDefinedParam_1 = param || lastDefinedParam_1;\r\n            if (!param) {\r\n                param = lastDefinedParam_1;\r\n            }\r\n            return param;\r\n        });\r\n    }\r\n    else {\r\n        definedParams = ruleSchema.params;\r\n    }\r\n    // Match the provided array length with a temporary schema.\r\n    for (var i = 0; i < definedParams.length; i++) {\r\n        var options = definedParams[i];\r\n        var value = options.default;\r\n        // if the provided is an array, map element value.\r\n        if (Array.isArray(provided)) {\r\n            if (i in provided) {\r\n                value = provided[i];\r\n            }\r\n        }\r\n        else {\r\n            // If the param exists in the provided object.\r\n            if (options.name in provided) {\r\n                value = provided[options.name];\r\n                // if the provided is the first param value.\r\n            }\r\n            else if (definedParams.length === 1) {\r\n                value = provided;\r\n            }\r\n        }\r\n        // if the param is a target, resolve the target value.\r\n        if (options.isTarget) {\r\n            value = createLocator(value, options.cast);\r\n        }\r\n        // A target param using interpolation\r\n        if (typeof value === 'string' && value[0] === '@') {\r\n            value = createLocator(value.slice(1), options.cast);\r\n        }\r\n        // If there is a transformer defined.\r\n        if (!isLocator(value) && options.cast) {\r\n            value = options.cast(value);\r\n        }\r\n        // already been set, probably multiple values.\r\n        if (params[options.name]) {\r\n            params[options.name] = Array.isArray(params[options.name]) ? params[options.name] : [params[options.name]];\r\n            params[options.name].push(value);\r\n        }\r\n        else {\r\n            // set the value.\r\n            params[options.name] = value;\r\n        }\r\n    }\r\n    return params;\r\n}\r\n/**\r\n * Parses a rule string expression.\r\n */\r\nvar parseRule = function (rule) {\r\n    var params = [];\r\n    var name = rule.split(':')[0];\r\n    if (includes(rule, ':')) {\r\n        params = rule\r\n            .split(':')\r\n            .slice(1)\r\n            .join(':')\r\n            .split(',');\r\n    }\r\n    return { name: name, params: params };\r\n};\r\nfunction createLocator(value, castFn) {\r\n    var locator = function (crossTable) {\r\n        var val = crossTable[value];\r\n        return castFn ? castFn(val) : val;\r\n    };\r\n    locator.__locatorRef = value;\r\n    return locator;\r\n}\r\nfunction extractLocators(params) {\r\n    if (Array.isArray(params)) {\r\n        return params.filter(isLocator);\r\n    }\r\n    return Object.keys(params)\r\n        .filter(function (key) { return isLocator(params[key]); })\r\n        .map(function (key) { return params[key]; });\r\n}\n\n/**\r\n * Validates a value against the rules.\r\n */\r\nfunction validate(value, rules, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var _a, _b, _c, _d, _e, _f;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var shouldBail, skipIfEmpty, field, result, errors, failedRules, regenerateMap;\r\n        return __generator(this, function (_g) {\r\n            switch (_g.label) {\r\n                case 0:\r\n                    shouldBail = (_a = options) === null || _a === void 0 ? void 0 : _a.bails;\r\n                    skipIfEmpty = (_b = options) === null || _b === void 0 ? void 0 : _b.skipIfEmpty;\r\n                    field = {\r\n                        name: ((_c = options) === null || _c === void 0 ? void 0 : _c.name) || '{field}',\r\n                        rules: normalizeRules(rules),\r\n                        bails: (shouldBail !== null && shouldBail !== void 0 ? shouldBail : true),\r\n                        skipIfEmpty: (skipIfEmpty !== null && skipIfEmpty !== void 0 ? skipIfEmpty : true),\r\n                        forceRequired: false,\r\n                        crossTable: ((_d = options) === null || _d === void 0 ? void 0 : _d.values) || {},\r\n                        names: ((_e = options) === null || _e === void 0 ? void 0 : _e.names) || {},\r\n                        customMessages: ((_f = options) === null || _f === void 0 ? void 0 : _f.customMessages) || {}\r\n                    };\r\n                    return [4 /*yield*/, _validate(field, value, options)];\r\n                case 1:\r\n                    result = _g.sent();\r\n                    errors = [];\r\n                    failedRules = {};\r\n                    regenerateMap = {};\r\n                    result.errors.forEach(function (e) {\r\n                        var msg = e.msg();\r\n                        errors.push(msg);\r\n                        failedRules[e.rule] = msg;\r\n                        regenerateMap[e.rule] = e.msg;\r\n                    });\r\n                    return [2 /*return*/, {\r\n                            valid: result.valid,\r\n                            errors: errors,\r\n                            failedRules: failedRules,\r\n                            regenerateMap: regenerateMap\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Starts the validation process.\r\n */\r\nfunction _validate(field, value, _a) {\r\n    var _b = (_a === void 0 ? {} : _a).isInitial, isInitial = _b === void 0 ? false : _b;\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _c, shouldSkip, errors, rules, length, i, rule, result;\r\n        return __generator(this, function (_d) {\r\n            switch (_d.label) {\r\n                case 0: return [4 /*yield*/, _shouldSkip(field, value)];\r\n                case 1:\r\n                    _c = _d.sent(), shouldSkip = _c.shouldSkip, errors = _c.errors;\r\n                    if (shouldSkip) {\r\n                        return [2 /*return*/, {\r\n                                valid: !errors.length,\r\n                                errors: errors\r\n                            }];\r\n                    }\r\n                    rules = Object.keys(field.rules).filter(function (rule) { return !RuleContainer.isRequireRule(rule); });\r\n                    length = rules.length;\r\n                    i = 0;\r\n                    _d.label = 2;\r\n                case 2:\r\n                    if (!(i < length)) return [3 /*break*/, 5];\r\n                    if (isInitial && RuleContainer.isLazy(rules[i])) {\r\n                        return [3 /*break*/, 4];\r\n                    }\r\n                    rule = rules[i];\r\n                    return [4 /*yield*/, _test(field, value, {\r\n                            name: rule,\r\n                            params: field.rules[rule]\r\n                        })];\r\n                case 3:\r\n                    result = _d.sent();\r\n                    if (!result.valid && result.error) {\r\n                        errors.push(result.error);\r\n                        if (field.bails) {\r\n                            return [2 /*return*/, {\r\n                                    valid: false,\r\n                                    errors: errors\r\n                                }];\r\n                        }\r\n                    }\r\n                    _d.label = 4;\r\n                case 4:\r\n                    i++;\r\n                    return [3 /*break*/, 2];\r\n                case 5: return [2 /*return*/, {\r\n                        valid: !errors.length,\r\n                        errors: errors\r\n                    }];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction _shouldSkip(field, value) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var requireRules, length, errors, isEmpty, isEmptyAndOptional, isRequired, i, rule, result;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    requireRules = Object.keys(field.rules).filter(RuleContainer.isRequireRule);\r\n                    length = requireRules.length;\r\n                    errors = [];\r\n                    isEmpty = isNullOrUndefined(value) || value === '' || isEmptyArray(value);\r\n                    isEmptyAndOptional = isEmpty && field.skipIfEmpty;\r\n                    isRequired = false;\r\n                    i = 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    if (!(i < length)) return [3 /*break*/, 4];\r\n                    rule = requireRules[i];\r\n                    return [4 /*yield*/, _test(field, value, {\r\n                            name: rule,\r\n                            params: field.rules[rule]\r\n                        })];\r\n                case 2:\r\n                    result = _a.sent();\r\n                    if (!isObject(result)) {\r\n                        throw new Error('Require rules has to return an object (see docs)');\r\n                    }\r\n                    if (result.required) {\r\n                        isRequired = true;\r\n                    }\r\n                    if (!result.valid && result.error) {\r\n                        errors.push(result.error);\r\n                        // Exit early as the field is required and failed validation.\r\n                        if (field.bails) {\r\n                            return [2 /*return*/, {\r\n                                    shouldSkip: true,\r\n                                    errors: errors\r\n                                }];\r\n                        }\r\n                    }\r\n                    _a.label = 3;\r\n                case 3:\r\n                    i++;\r\n                    return [3 /*break*/, 1];\r\n                case 4:\r\n                    if (isEmpty && !isRequired && !field.skipIfEmpty) {\r\n                        return [2 /*return*/, {\r\n                                shouldSkip: false,\r\n                                errors: errors\r\n                            }];\r\n                    }\r\n                    // field is configured to run through the pipeline regardless\r\n                    if (!field.bails && !isEmptyAndOptional) {\r\n                        return [2 /*return*/, {\r\n                                shouldSkip: false,\r\n                                errors: errors\r\n                            }];\r\n                    }\r\n                    // skip if the field is not required and has an empty value.\r\n                    return [2 /*return*/, {\r\n                            shouldSkip: !isRequired && isEmpty,\r\n                            errors: errors\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Tests a single input value against a rule.\r\n */\r\nfunction _test(field, value, rule) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var ruleSchema, normalizedValue, params, result, values_1;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    ruleSchema = RuleContainer.getRuleDefinition(rule.name);\r\n                    if (!ruleSchema || !ruleSchema.validate) {\r\n                        throw new Error(\"No such validator '\" + rule.name + \"' exists.\");\r\n                    }\r\n                    normalizedValue = ruleSchema.castValue ? ruleSchema.castValue(value) : value;\r\n                    params = fillTargetValues(rule.params, field.crossTable);\r\n                    return [4 /*yield*/, ruleSchema.validate(normalizedValue, params)];\r\n                case 1:\r\n                    result = _a.sent();\r\n                    if (typeof result === 'string') {\r\n                        values_1 = __assign(__assign({}, (params || {})), { _field_: field.name, _value_: value, _rule_: rule.name });\r\n                        return [2 /*return*/, {\r\n                                valid: false,\r\n                                error: { rule: rule.name, msg: function () { return interpolate(result, values_1); } }\r\n                            }];\r\n                    }\r\n                    if (!isObject(result)) {\r\n                        result = { valid: result };\r\n                    }\r\n                    return [2 /*return*/, {\r\n                            valid: result.valid,\r\n                            required: result.required,\r\n                            error: result.valid ? undefined : _generateFieldError(field, value, ruleSchema, rule.name, params)\r\n                        }];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Generates error messages.\r\n */\r\nfunction _generateFieldError(field, value, ruleSchema, ruleName, params) {\r\n    var _a;\r\n    var message = (_a = field.customMessages[ruleName], (_a !== null && _a !== void 0 ? _a : ruleSchema.message));\r\n    var ruleTargets = _getRuleTargets(field, ruleSchema, ruleName);\r\n    var _b = _getUserTargets(field, ruleSchema, ruleName, message), userTargets = _b.userTargets, userMessage = _b.userMessage;\r\n    var values = __assign(__assign(__assign(__assign({}, (params || {})), { _field_: field.name, _value_: value, _rule_: ruleName }), ruleTargets), userTargets);\r\n    return {\r\n        msg: function () { return _normalizeMessage(userMessage || getConfig().defaultMessage, field.name, values); },\r\n        rule: ruleName\r\n    };\r\n}\r\nfunction _getRuleTargets(field, ruleSchema, ruleName) {\r\n    var params = ruleSchema.params;\r\n    if (!params) {\r\n        return {};\r\n    }\r\n    var numTargets = params.filter(function (param) { return param.isTarget; }).length;\r\n    if (numTargets <= 0) {\r\n        return {};\r\n    }\r\n    var names = {};\r\n    var ruleConfig = field.rules[ruleName];\r\n    if (!Array.isArray(ruleConfig) && isObject(ruleConfig)) {\r\n        ruleConfig = params.map(function (param) {\r\n            return ruleConfig[param.name];\r\n        });\r\n    }\r\n    for (var index = 0; index < params.length; index++) {\r\n        var param = params[index];\r\n        var key = ruleConfig[index];\r\n        if (!isLocator(key)) {\r\n            continue;\r\n        }\r\n        key = key.__locatorRef;\r\n        var name_1 = field.names[key] || key;\r\n        names[param.name] = name_1;\r\n        names[\"_\" + param.name + \"_\"] = field.crossTable[key];\r\n    }\r\n    return names;\r\n}\r\nfunction _getUserTargets(field, ruleSchema, ruleName, userMessage) {\r\n    var userTargets = {};\r\n    var rules = field.rules[ruleName];\r\n    var params = ruleSchema.params || [];\r\n    // early return if no rules\r\n    if (!rules) {\r\n        return {};\r\n    }\r\n    // check all rules to convert targets\r\n    Object.keys(rules).forEach(function (key, index) {\r\n        // get the rule\r\n        var rule = rules[key];\r\n        if (!isLocator(rule)) {\r\n            return {};\r\n        }\r\n        // get associated parameter\r\n        var param = params[index];\r\n        if (!param) {\r\n            return {};\r\n        }\r\n        // grab the name of the target\r\n        var name = rule.__locatorRef;\r\n        userTargets[param.name] = field.names[name] || name;\r\n        userTargets[\"_\" + param.name + \"_\"] = field.crossTable[name];\r\n    });\r\n    return {\r\n        userTargets: userTargets,\r\n        userMessage: userMessage\r\n    };\r\n}\r\nfunction _normalizeMessage(template, field, values) {\r\n    if (typeof template === 'function') {\r\n        return template(field, values);\r\n    }\r\n    return interpolate(template, __assign(__assign({}, values), { _field_: field }));\r\n}\r\nfunction fillTargetValues(params, crossTable) {\r\n    if (Array.isArray(params)) {\r\n        return params;\r\n    }\r\n    var values = {};\r\n    var normalize = function (value) {\r\n        if (isLocator(value)) {\r\n            return value(crossTable);\r\n        }\r\n        return value;\r\n    };\r\n    Object.keys(params).forEach(function (param) {\r\n        values[param] = normalize(params[param]);\r\n    });\r\n    return values;\r\n}\n\nvar aggressive = function () { return ({\r\n    on: ['input', 'blur']\r\n}); };\r\nvar lazy = function () { return ({\r\n    on: ['change']\r\n}); };\r\nvar eager = function (_a) {\r\n    var errors = _a.errors;\r\n    if (errors.length) {\r\n        return {\r\n            on: ['input', 'change']\r\n        };\r\n    }\r\n    return {\r\n        on: ['change', 'blur']\r\n    };\r\n};\r\nvar passive = function () { return ({\r\n    on: []\r\n}); };\r\nvar modes = {\r\n    aggressive: aggressive,\r\n    eager: eager,\r\n    passive: passive,\r\n    lazy: lazy\r\n};\r\nvar setInteractionMode = function (mode, implementation) {\r\n    setConfig({ mode: mode });\r\n    if (!implementation) {\r\n        return;\r\n    }\r\n    if (!isCallable(implementation)) {\r\n        throw new Error('A mode implementation must be a function');\r\n    }\r\n    modes[mode] = implementation;\r\n};\n\nvar EVENT_BUS = new vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\r\nfunction localeChanged() {\r\n    EVENT_BUS.$emit('change:locale');\r\n}\n\nvar Dictionary = /** @class */ (function () {\r\n    function Dictionary(locale, dictionary) {\r\n        this.container = {};\r\n        this.locale = locale;\r\n        this.merge(dictionary);\r\n    }\r\n    Dictionary.prototype.resolve = function (field, rule, values) {\r\n        return this.format(this.locale, field, rule, values);\r\n    };\r\n    Dictionary.prototype.format = function (locale, field, rule, values) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        var message;\r\n        // find if specific message for that field was specified.\r\n        message = ((_c = (_b = (_a = this.container[locale]) === null || _a === void 0 ? void 0 : _a.fields) === null || _b === void 0 ? void 0 : _b[field]) === null || _c === void 0 ? void 0 : _c[rule]) || ((_e = (_d = this.container[locale]) === null || _d === void 0 ? void 0 : _d.messages) === null || _e === void 0 ? void 0 : _e[rule]);\r\n        if (!message) {\r\n            message = '{field} is not valid';\r\n        }\r\n        field = (_h = (_g = (_f = this.container[locale]) === null || _f === void 0 ? void 0 : _f.names) === null || _g === void 0 ? void 0 : _g[field], (_h !== null && _h !== void 0 ? _h : field));\r\n        return isCallable(message) ? message(field, values) : interpolate(message, __assign(__assign({}, values), { _field_: field }));\r\n    };\r\n    Dictionary.prototype.merge = function (dictionary) {\r\n        merge(this.container, dictionary);\r\n    };\r\n    Dictionary.prototype.hasRule = function (name) {\r\n        var _a, _b;\r\n        return !!((_b = (_a = this.container[this.locale]) === null || _a === void 0 ? void 0 : _a.messages) === null || _b === void 0 ? void 0 : _b[name]);\r\n    };\r\n    return Dictionary;\r\n}());\r\nvar DICTIONARY;\r\nfunction localize(locale, dictionary) {\r\n    var _a;\r\n    if (!DICTIONARY) {\r\n        DICTIONARY = new Dictionary('en', {});\r\n        setConfig({\r\n            defaultMessage: function (field, values) {\r\n                var _a;\r\n                return DICTIONARY.resolve(field, (_a = values) === null || _a === void 0 ? void 0 : _a._rule_, values || {});\r\n            }\r\n        });\r\n    }\r\n    if (typeof locale === 'string') {\r\n        DICTIONARY.locale = locale;\r\n        if (dictionary) {\r\n            DICTIONARY.merge((_a = {}, _a[locale] = dictionary, _a));\r\n        }\r\n        localeChanged();\r\n        return;\r\n    }\r\n    DICTIONARY.merge(locale);\r\n}\n\nvar isEvent = function (evt) {\r\n    if (!evt) {\r\n        return false;\r\n    }\r\n    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\r\n        return true;\r\n    }\r\n    // this is for IE\r\n    /* istanbul ignore next */\r\n    if (evt && evt.srcElement) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nfunction normalizeEventValue(value) {\r\n    var _a, _b;\r\n    if (!isEvent(value)) {\r\n        return value;\r\n    }\r\n    var input = value.target;\r\n    if (input.type === 'file' && input.files) {\r\n        return toArray(input.files);\r\n    }\r\n    // If the input has a `v-model.number` modifier applied.\r\n    if ((_a = input._vModifiers) === null || _a === void 0 ? void 0 : _a.number) {\r\n        // as per the spec the v-model.number uses parseFloat\r\n        var valueAsNumber = parseFloat(input.value);\r\n        if (isNaN(valueAsNumber)) {\r\n            return input.value;\r\n        }\r\n        return valueAsNumber;\r\n    }\r\n    if ((_b = input._vModifiers) === null || _b === void 0 ? void 0 : _b.trim) {\r\n        var trimmedValue = typeof input.value === 'string' ? input.value.trim() : input.value;\r\n        return trimmedValue;\r\n    }\r\n    return input.value;\r\n}\n\nvar isTextInput = function (vnode) {\r\n    var _a, _b;\r\n    var attrs = ((_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs) || vnode.elm;\r\n    // it will fallback to being a text input per browsers spec.\r\n    if (vnode.tag === 'input' && (!attrs || !attrs.type)) {\r\n        return true;\r\n    }\r\n    if (vnode.tag === 'textarea') {\r\n        return true;\r\n    }\r\n    return includes(['text', 'password', 'search', 'email', 'tel', 'url', 'number'], (_b = attrs) === null || _b === void 0 ? void 0 : _b.type);\r\n};\r\n// export const isCheckboxOrRadioInput = (vnode: VNode): boolean => {\r\n//   const attrs = (vnode.data && vnode.data.attrs) || vnode.elm;\r\n//   return includes(['radio', 'checkbox'], attrs && attrs.type);\r\n// };\r\n// Gets the model object on the vnode.\r\nfunction findModel(vnode) {\r\n    if (!vnode.data) {\r\n        return undefined;\r\n    }\r\n    // Component Model\r\n    // THIS IS NOT TYPED IN OFFICIAL VUE TYPINGS\r\n    // eslint-disable-next-line\r\n    var nonStandardVNodeData = vnode.data;\r\n    if ('model' in nonStandardVNodeData) {\r\n        return nonStandardVNodeData.model;\r\n    }\r\n    if (!vnode.data.directives) {\r\n        return undefined;\r\n    }\r\n    return find(vnode.data.directives, function (d) { return d.name === 'model'; });\r\n}\r\nfunction findValue(vnode) {\r\n    var _a, _b, _c;\r\n    var model = findModel(vnode);\r\n    if (model) {\r\n        return { value: model.value };\r\n    }\r\n    var config = findModelConfig(vnode);\r\n    var prop = ((_a = config) === null || _a === void 0 ? void 0 : _a.prop) || 'value';\r\n    if (((_b = vnode.componentOptions) === null || _b === void 0 ? void 0 : _b.propsData) && prop in vnode.componentOptions.propsData) {\r\n        var propsDataWithValue = vnode.componentOptions.propsData;\r\n        return { value: propsDataWithValue[prop] };\r\n    }\r\n    if (((_c = vnode.data) === null || _c === void 0 ? void 0 : _c.domProps) && 'value' in vnode.data.domProps) {\r\n        return { value: vnode.data.domProps.value };\r\n    }\r\n    return undefined;\r\n}\r\nfunction extractChildren(vnode) {\r\n    if (Array.isArray(vnode)) {\r\n        return vnode;\r\n    }\r\n    if (Array.isArray(vnode.children)) {\r\n        return vnode.children;\r\n    }\r\n    /* istanbul ignore next */\r\n    if (vnode.componentOptions && Array.isArray(vnode.componentOptions.children)) {\r\n        return vnode.componentOptions.children;\r\n    }\r\n    return [];\r\n}\r\nfunction extractVNodes(vnode) {\r\n    if (!Array.isArray(vnode) && findValue(vnode) !== undefined) {\r\n        return [vnode];\r\n    }\r\n    var children = extractChildren(vnode);\r\n    return children.reduce(function (nodes, node) {\r\n        var candidates = extractVNodes(node);\r\n        if (candidates.length) {\r\n            nodes.push.apply(nodes, candidates);\r\n        }\r\n        return nodes;\r\n    }, []);\r\n}\r\n// Resolves v-model config if exists.\r\nfunction findModelConfig(vnode) {\r\n    /* istanbul ignore next */\r\n    if (!vnode.componentOptions)\r\n        return null;\r\n    // This is also not typed in the standard Vue TS.\r\n    return vnode.componentOptions.Ctor.options.model;\r\n}\r\n// Adds a listener to vnode listener object.\r\nfunction mergeVNodeListeners(obj, eventName, handler) {\r\n    // no listener at all.\r\n    if (isNullOrUndefined(obj[eventName])) {\r\n        obj[eventName] = [handler];\r\n        return;\r\n    }\r\n    // Is an invoker.\r\n    if (isCallable(obj[eventName]) && obj[eventName].fns) {\r\n        var invoker = obj[eventName];\r\n        invoker.fns = Array.isArray(invoker.fns) ? invoker.fns : [invoker.fns];\r\n        if (!includes(invoker.fns, handler)) {\r\n            invoker.fns.push(handler);\r\n        }\r\n        return;\r\n    }\r\n    if (isCallable(obj[eventName])) {\r\n        var prev = obj[eventName];\r\n        obj[eventName] = [prev];\r\n    }\r\n    if (Array.isArray(obj[eventName]) && !includes(obj[eventName], handler)) {\r\n        obj[eventName].push(handler);\r\n    }\r\n}\r\n// Adds a listener to a native HTML vnode.\r\nfunction addNativeNodeListener(node, eventName, handler) {\r\n    /* istanbul ignore next */\r\n    if (!node.data) {\r\n        node.data = {};\r\n    }\r\n    if (isNullOrUndefined(node.data.on)) {\r\n        node.data.on = {};\r\n    }\r\n    mergeVNodeListeners(node.data.on, eventName, handler);\r\n}\r\n// Adds a listener to a Vue component vnode.\r\nfunction addComponentNodeListener(node, eventName, handler) {\r\n    /* istanbul ignore next */\r\n    if (!node.componentOptions) {\r\n        return;\r\n    }\r\n    /* istanbul ignore next */\r\n    if (!node.componentOptions.listeners) {\r\n        node.componentOptions.listeners = {};\r\n    }\r\n    mergeVNodeListeners(node.componentOptions.listeners, eventName, handler);\r\n}\r\nfunction addVNodeListener(vnode, eventName, handler) {\r\n    if (vnode.componentOptions) {\r\n        addComponentNodeListener(vnode, eventName, handler);\r\n        return;\r\n    }\r\n    addNativeNodeListener(vnode, eventName, handler);\r\n}\r\n// Determines if `change` should be used over `input` for listeners.\r\nfunction getInputEventName(vnode, model) {\r\n    var _a, _b;\r\n    // Is a component.\r\n    if (vnode.componentOptions) {\r\n        var event_1 = (findModelConfig(vnode) || { event: 'input' }).event;\r\n        return event_1;\r\n    }\r\n    // Lazy Models typically use change event\r\n    if ((_b = (_a = model) === null || _a === void 0 ? void 0 : _a.modifiers) === null || _b === void 0 ? void 0 : _b.lazy) {\r\n        return 'change';\r\n    }\r\n    // is a textual-type input.\r\n    if (isTextInput(vnode)) {\r\n        return 'input';\r\n    }\r\n    return 'change';\r\n}\r\nfunction isHTMLNode(node) {\r\n    return includes(['input', 'select', 'textarea'], node.tag);\r\n}\r\n// TODO: Type this one properly.\r\nfunction normalizeSlots(slots, ctx) {\r\n    var acc = [];\r\n    return Object.keys(slots).reduce(function (arr, key) {\r\n        slots[key].forEach(function (vnode) {\r\n            if (!vnode.context) {\r\n                slots[key].context = ctx;\r\n                if (!vnode.data) {\r\n                    vnode.data = {};\r\n                }\r\n                vnode.data.slot = key;\r\n            }\r\n        });\r\n        return arr.concat(slots[key]);\r\n    }, acc);\r\n}\r\nfunction resolveTextualRules(vnode) {\r\n    var _a;\r\n    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;\r\n    var rules = {};\r\n    if (!attrs)\r\n        return rules;\r\n    if (attrs.type === 'email' && RuleContainer.getRuleDefinition('email')) {\r\n        rules.email = ['multiple' in attrs];\r\n    }\r\n    if (attrs.pattern && RuleContainer.getRuleDefinition('regex')) {\r\n        rules.regex = attrs.pattern;\r\n    }\r\n    if (attrs.maxlength >= 0 && RuleContainer.getRuleDefinition('max')) {\r\n        rules.max = attrs.maxlength;\r\n    }\r\n    if (attrs.minlength >= 0 && RuleContainer.getRuleDefinition('min')) {\r\n        rules.min = attrs.minlength;\r\n    }\r\n    if (attrs.type === 'number') {\r\n        if (isSpecified(attrs.min) && RuleContainer.getRuleDefinition('min_value')) {\r\n            rules.min_value = Number(attrs.min);\r\n        }\r\n        if (isSpecified(attrs.max) && RuleContainer.getRuleDefinition('max_value')) {\r\n            rules.max_value = Number(attrs.max);\r\n        }\r\n    }\r\n    return rules;\r\n}\r\nfunction resolveRules(vnode) {\r\n    var _a;\r\n    var htmlTags = ['input', 'select', 'textarea'];\r\n    var attrs = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.attrs;\r\n    if (!includes(htmlTags, vnode.tag) || !attrs) {\r\n        return {};\r\n    }\r\n    var rules = {};\r\n    if ('required' in attrs && attrs.required !== false && RuleContainer.getRuleDefinition('required')) {\r\n        rules.required = attrs.type === 'checkbox' ? [true] : true;\r\n    }\r\n    if (isTextInput(vnode)) {\r\n        return normalizeRules(__assign(__assign({}, rules), resolveTextualRules(vnode)));\r\n    }\r\n    return normalizeRules(rules);\r\n}\r\nfunction normalizeChildren(context, slotProps) {\r\n    if (context.$scopedSlots.default) {\r\n        return context.$scopedSlots.default(slotProps) || [];\r\n    }\r\n    return context.$slots.default || [];\r\n}\n\n/**\r\n * Determines if a provider needs to run validation.\r\n */\r\nfunction shouldValidate(ctx, value) {\r\n    // when an immediate/initial validation is needed and wasn't done before.\r\n    if (!ctx._ignoreImmediate && ctx.immediate) {\r\n        return true;\r\n    }\r\n    // when the value changes for whatever reason.\r\n    if (ctx.value !== value && ctx.normalizedEvents.length) {\r\n        return true;\r\n    }\r\n    // when it needs validation due to props/cross-fields changes.\r\n    if (ctx._needsValidation) {\r\n        return true;\r\n    }\r\n    // when the initial value is undefined and the field wasn't rendered yet.\r\n    if (!ctx.initialized && value === undefined) {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nfunction createValidationCtx(ctx) {\r\n    return __assign(__assign({}, ctx.flags), { errors: ctx.errors, classes: ctx.classes, failedRules: ctx.failedRules, reset: function () { return ctx.reset(); }, validate: function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return ctx.validate.apply(ctx, args);\r\n        }, ariaInput: {\r\n            'aria-invalid': ctx.flags.invalid ? 'true' : 'false',\r\n            'aria-required': ctx.isRequired ? 'true' : 'false',\r\n            'aria-errormessage': \"vee_\" + ctx.id\r\n        }, ariaMsg: {\r\n            id: \"vee_\" + ctx.id,\r\n            'aria-live': ctx.errors.length ? 'assertive' : 'off'\r\n        } });\r\n}\r\nfunction onRenderUpdate(vm, value) {\r\n    if (!vm.initialized) {\r\n        vm.initialValue = value;\r\n    }\r\n    var validateNow = shouldValidate(vm, value);\r\n    vm._needsValidation = false;\r\n    vm.value = value;\r\n    vm._ignoreImmediate = true;\r\n    if (!validateNow) {\r\n        return;\r\n    }\r\n    var validate = function () {\r\n        if (vm.immediate || vm.flags.validated) {\r\n            return triggerThreadSafeValidation(vm);\r\n        }\r\n        vm.validateSilent();\r\n    };\r\n    if (vm.initialized) {\r\n        validate();\r\n        return;\r\n    }\r\n    vm.$once('hook:mounted', function () { return validate(); });\r\n}\r\nfunction computeModeSetting(ctx) {\r\n    var compute = (isCallable(ctx.mode) ? ctx.mode : modes[ctx.mode]);\r\n    return compute(ctx);\r\n}\r\nfunction triggerThreadSafeValidation(vm) {\r\n    var pendingPromise = vm.validateSilent();\r\n    // avoids race conditions between successive validations.\r\n    vm._pendingValidation = pendingPromise;\r\n    return pendingPromise.then(function (result) {\r\n        if (pendingPromise === vm._pendingValidation) {\r\n            vm.applyResult(result);\r\n            vm._pendingValidation = undefined;\r\n        }\r\n        return result;\r\n    });\r\n}\r\n// Creates the common handlers for a validatable context.\r\nfunction createCommonHandlers(vm) {\r\n    if (!vm.$veeOnInput) {\r\n        vm.$veeOnInput = function (e) {\r\n            vm.syncValue(e); // track and keep the value updated.\r\n            vm.setFlags({ dirty: true, pristine: false });\r\n        };\r\n    }\r\n    var onInput = vm.$veeOnInput;\r\n    if (!vm.$veeOnBlur) {\r\n        vm.$veeOnBlur = function () {\r\n            vm.setFlags({ touched: true, untouched: false });\r\n        };\r\n    }\r\n    // Blur event listener.\r\n    var onBlur = vm.$veeOnBlur;\r\n    var onValidate = vm.$veeHandler;\r\n    var mode = computeModeSetting(vm);\r\n    // Handle debounce changes.\r\n    if (!onValidate || vm.$veeDebounce !== vm.debounce) {\r\n        onValidate = debounce(function () {\r\n            vm.$nextTick(function () {\r\n                if (!vm._pendingReset) {\r\n                    triggerThreadSafeValidation(vm);\r\n                }\r\n                vm._pendingReset = false;\r\n            });\r\n        }, mode.debounce || vm.debounce);\r\n        // Cache the handler so we don't create it each time.\r\n        vm.$veeHandler = onValidate;\r\n        // cache the debounce value so we detect if it was changed.\r\n        vm.$veeDebounce = vm.debounce;\r\n    }\r\n    return { onInput: onInput, onBlur: onBlur, onValidate: onValidate };\r\n}\r\n// Adds all plugin listeners to the vnode.\r\nfunction addListeners(vm, node) {\r\n    var _a;\r\n    var value = findValue(node);\r\n    // cache the input eventName.\r\n    vm._inputEventName = vm._inputEventName || getInputEventName(node, findModel(node));\r\n    onRenderUpdate(vm, (_a = value) === null || _a === void 0 ? void 0 : _a.value);\r\n    var _b = createCommonHandlers(vm), onInput = _b.onInput, onBlur = _b.onBlur, onValidate = _b.onValidate;\r\n    addVNodeListener(node, vm._inputEventName, onInput);\r\n    addVNodeListener(node, 'blur', onBlur);\r\n    // add the validation listeners.\r\n    vm.normalizedEvents.forEach(function (evt) {\r\n        addVNodeListener(node, evt, onValidate);\r\n    });\r\n    vm.initialized = true;\r\n}\n\nvar PROVIDER_COUNTER = 0;\r\nfunction data() {\r\n    var errors = [];\r\n    var fieldName = '';\r\n    var defaultValues = {\r\n        errors: errors,\r\n        value: undefined,\r\n        initialized: false,\r\n        initialValue: undefined,\r\n        flags: createFlags(),\r\n        failedRules: {},\r\n        isActive: true,\r\n        fieldName: fieldName,\r\n        id: ''\r\n    };\r\n    return defaultValues;\r\n}\r\nvar ValidationProvider = vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\r\n    inject: {\r\n        $_veeObserver: {\r\n            from: '$_veeObserver',\r\n            default: function () {\r\n                if (!this.$vnode.context.$_veeObserver) {\r\n                    this.$vnode.context.$_veeObserver = createObserver();\r\n                }\r\n                return this.$vnode.context.$_veeObserver;\r\n            }\r\n        }\r\n    },\r\n    props: {\r\n        vid: {\r\n            type: String,\r\n            default: ''\r\n        },\r\n        name: {\r\n            type: String,\r\n            default: null\r\n        },\r\n        mode: {\r\n            type: [String, Function],\r\n            default: function () {\r\n                return getConfig().mode;\r\n            }\r\n        },\r\n        rules: {\r\n            type: [Object, String],\r\n            default: null\r\n        },\r\n        immediate: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        bails: {\r\n            type: Boolean,\r\n            default: function () { return getConfig().bails; }\r\n        },\r\n        skipIfEmpty: {\r\n            type: Boolean,\r\n            default: function () { return getConfig().skipOptional; }\r\n        },\r\n        debounce: {\r\n            type: Number,\r\n            default: 0\r\n        },\r\n        tag: {\r\n            type: String,\r\n            default: 'span'\r\n        },\r\n        slim: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        disabled: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        customMessages: {\r\n            type: Object,\r\n            default: function () {\r\n                return {};\r\n            }\r\n        }\r\n    },\r\n    watch: {\r\n        rules: {\r\n            deep: true,\r\n            handler: function (val, oldVal) {\r\n                this._needsValidation = !isEqual(val, oldVal);\r\n            }\r\n        }\r\n    },\r\n    data: data,\r\n    computed: {\r\n        fieldDeps: function () {\r\n            var _this = this;\r\n            return Object.keys(this.normalizedRules).reduce(function (acc, rule) {\r\n                var deps = extractLocators(_this.normalizedRules[rule]).map(function (dep) { return dep.__locatorRef; });\r\n                acc.push.apply(acc, deps);\r\n                deps.forEach(function (depName) {\r\n                    watchCrossFieldDep(_this, depName);\r\n                });\r\n                return acc;\r\n            }, []);\r\n        },\r\n        normalizedEvents: function () {\r\n            var _this = this;\r\n            var on = computeModeSetting(this).on;\r\n            return (on || []).map(function (e) {\r\n                if (e === 'input') {\r\n                    return _this._inputEventName;\r\n                }\r\n                return e;\r\n            });\r\n        },\r\n        isRequired: function () {\r\n            var rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);\r\n            var isRequired = Object.keys(rules).some(RuleContainer.isRequireRule);\r\n            this.flags.required = !!isRequired;\r\n            return isRequired;\r\n        },\r\n        classes: function () {\r\n            var names = getConfig().classes;\r\n            return computeClassObj(names, this.flags);\r\n        },\r\n        normalizedRules: function () {\r\n            return normalizeRules(this.rules);\r\n        }\r\n    },\r\n    mounted: function () {\r\n        var _this = this;\r\n        var onLocaleChanged = function () {\r\n            if (!_this.flags.validated) {\r\n                return;\r\n            }\r\n            var regenerateMap = _this._regenerateMap;\r\n            if (regenerateMap) {\r\n                var errors_1 = [];\r\n                var failedRules_1 = {};\r\n                Object.keys(regenerateMap).forEach(function (rule) {\r\n                    var msg = regenerateMap[rule]();\r\n                    errors_1.push(msg);\r\n                    failedRules_1[rule] = msg;\r\n                });\r\n                _this.applyResult({ errors: errors_1, failedRules: failedRules_1, regenerateMap: regenerateMap });\r\n                return;\r\n            }\r\n            _this.validate();\r\n        };\r\n        EVENT_BUS.$on('change:locale', onLocaleChanged);\r\n        this.$on('hook:beforeDestroy', function () {\r\n            EVENT_BUS.$off('change:locale', onLocaleChanged);\r\n        });\r\n    },\r\n    render: function (h) {\r\n        var _this = this;\r\n        this.registerField();\r\n        var ctx = createValidationCtx(this);\r\n        var children = normalizeChildren(this, ctx);\r\n        // Handle single-root slot.\r\n        extractVNodes(children).forEach(function (input) {\r\n            var _a, _b, _c, _d;\r\n            // resolved rules are not reactive because it has a new reference each time.\r\n            // causing infinite render-loops.\r\n            // So we are comparing them manually to decide if we need to validate or not.\r\n            var resolved = getConfig().useConstraintAttrs ? resolveRules(input) : {};\r\n            if (!isEqual(_this._resolvedRules, resolved)) {\r\n                _this._needsValidation = true;\r\n            }\r\n            if (isHTMLNode(input)) {\r\n                _this.fieldName = ((_b = (_a = input.data) === null || _a === void 0 ? void 0 : _a.attrs) === null || _b === void 0 ? void 0 : _b.name) || ((_d = (_c = input.data) === null || _c === void 0 ? void 0 : _c.attrs) === null || _d === void 0 ? void 0 : _d.id);\r\n            }\r\n            _this._resolvedRules = resolved;\r\n            addListeners(_this, input);\r\n        });\r\n        return this.slim && children.length <= 1 ? children[0] : h(this.tag, children);\r\n    },\r\n    beforeDestroy: function () {\r\n        // cleanup reference.\r\n        this.$_veeObserver.unobserve(this.id);\r\n    },\r\n    activated: function () {\r\n        this.isActive = true;\r\n    },\r\n    deactivated: function () {\r\n        this.isActive = false;\r\n    },\r\n    methods: {\r\n        setFlags: function (flags) {\r\n            var _this = this;\r\n            Object.keys(flags).forEach(function (flag) {\r\n                _this.flags[flag] = flags[flag];\r\n            });\r\n        },\r\n        syncValue: function (v) {\r\n            var value = normalizeEventValue(v);\r\n            this.value = value;\r\n            this.flags.changed = this.initialValue !== value;\r\n        },\r\n        reset: function () {\r\n            var _this = this;\r\n            this.errors = [];\r\n            this.initialValue = this.value;\r\n            var flags = createFlags();\r\n            flags.required = this.isRequired;\r\n            this.setFlags(flags);\r\n            this.failedRules = {};\r\n            this.validateSilent();\r\n            this._pendingValidation = undefined;\r\n            this._pendingReset = true;\r\n            setTimeout(function () {\r\n                _this._pendingReset = false;\r\n            }, this.debounce);\r\n        },\r\n        validate: function () {\r\n            var args = [];\r\n            for (var _i = 0; _i < arguments.length; _i++) {\r\n                args[_i] = arguments[_i];\r\n            }\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                return __generator(this, function (_a) {\r\n                    if (args.length > 0) {\r\n                        this.syncValue(args[0]);\r\n                    }\r\n                    return [2 /*return*/, triggerThreadSafeValidation(this)];\r\n                });\r\n            });\r\n        },\r\n        validateSilent: function () {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var rules, result;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            this.setFlags({ pending: true });\r\n                            rules = __assign(__assign({}, this._resolvedRules), this.normalizedRules);\r\n                            Object.defineProperty(rules, '_$$isNormalized', {\r\n                                value: true,\r\n                                writable: false,\r\n                                enumerable: false,\r\n                                configurable: false\r\n                            });\r\n                            return [4 /*yield*/, validate(this.value, rules, __assign(__assign({ name: this.name || this.fieldName }, createLookup(this)), { bails: this.bails, skipIfEmpty: this.skipIfEmpty, isInitial: !this.initialized, customMessages: this.customMessages }))];\r\n                        case 1:\r\n                            result = _a.sent();\r\n                            this.setFlags({\r\n                                pending: false,\r\n                                valid: result.valid,\r\n                                invalid: !result.valid\r\n                            });\r\n                            return [2 /*return*/, result];\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        setErrors: function (errors) {\r\n            this.applyResult({ errors: errors, failedRules: {} });\r\n        },\r\n        applyResult: function (_a) {\r\n            var errors = _a.errors, failedRules = _a.failedRules, regenerateMap = _a.regenerateMap;\r\n            this.errors = errors;\r\n            this._regenerateMap = regenerateMap;\r\n            this.failedRules = __assign({}, (failedRules || {}));\r\n            this.setFlags({\r\n                valid: !errors.length,\r\n                passed: !errors.length,\r\n                invalid: !!errors.length,\r\n                failed: !!errors.length,\r\n                validated: true,\r\n                changed: this.value !== this.initialValue\r\n            });\r\n        },\r\n        registerField: function () {\r\n            updateRenderingContextRefs(this);\r\n        }\r\n    }\r\n});\r\nfunction computeClassObj(names, flags) {\r\n    var acc = {};\r\n    var keys = Object.keys(flags);\r\n    var length = keys.length;\r\n    var _loop_1 = function (i) {\r\n        var flag = keys[i];\r\n        var className = (names && names[flag]) || flag;\r\n        var value = flags[flag];\r\n        if (isNullOrUndefined(value)) {\r\n            return \"continue\";\r\n        }\r\n        if ((flag === 'valid' || flag === 'invalid') && !flags.validated) {\r\n            return \"continue\";\r\n        }\r\n        if (typeof className === 'string') {\r\n            acc[className] = value;\r\n        }\r\n        else if (Array.isArray(className)) {\r\n            className.forEach(function (cls) {\r\n                acc[cls] = value;\r\n            });\r\n        }\r\n    };\r\n    for (var i = 0; i < length; i++) {\r\n        _loop_1(i);\r\n    }\r\n    return acc;\r\n}\r\nfunction createLookup(vm) {\r\n    var providers = vm.$_veeObserver.refs;\r\n    var reduced = {\r\n        names: {},\r\n        values: {}\r\n    };\r\n    return vm.fieldDeps.reduce(function (acc, depName) {\r\n        if (!providers[depName]) {\r\n            return acc;\r\n        }\r\n        acc.values[depName] = providers[depName].value;\r\n        acc.names[depName] = providers[depName].name;\r\n        return acc;\r\n    }, reduced);\r\n}\r\nfunction extractId(vm) {\r\n    if (vm.vid) {\r\n        return vm.vid;\r\n    }\r\n    if (vm.name) {\r\n        return vm.name;\r\n    }\r\n    if (vm.id) {\r\n        return vm.id;\r\n    }\r\n    if (vm.fieldName) {\r\n        return vm.fieldName;\r\n    }\r\n    PROVIDER_COUNTER++;\r\n    return \"_vee_\" + PROVIDER_COUNTER;\r\n}\r\nfunction updateRenderingContextRefs(vm) {\r\n    var providedId = extractId(vm);\r\n    var id = vm.id;\r\n    // Nothing has changed.\r\n    if (!vm.isActive || (id === providedId && vm.$_veeObserver.refs[id])) {\r\n        return;\r\n    }\r\n    // vid was changed.\r\n    if (id !== providedId && vm.$_veeObserver.refs[id] === vm) {\r\n        vm.$_veeObserver.unobserve(id);\r\n    }\r\n    vm.id = providedId;\r\n    vm.$_veeObserver.observe(vm);\r\n}\r\nfunction createObserver() {\r\n    return {\r\n        refs: {},\r\n        observe: function (vm) {\r\n            this.refs[vm.id] = vm;\r\n        },\r\n        unobserve: function (id) {\r\n            delete this.refs[id];\r\n        }\r\n    };\r\n}\r\nfunction watchCrossFieldDep(ctx, depName, withHooks) {\r\n    if (withHooks === void 0) { withHooks = true; }\r\n    var providers = ctx.$_veeObserver.refs;\r\n    if (!ctx._veeWatchers) {\r\n        ctx._veeWatchers = {};\r\n    }\r\n    if (!providers[depName] && withHooks) {\r\n        return ctx.$once('hook:mounted', function () {\r\n            watchCrossFieldDep(ctx, depName, false);\r\n        });\r\n    }\r\n    if (!isCallable(ctx._veeWatchers[depName]) && providers[depName]) {\r\n        ctx._veeWatchers[depName] = providers[depName].$watch('value', function () {\r\n            if (ctx.flags.validated) {\r\n                ctx._needsValidation = true;\r\n                ctx.validate();\r\n            }\r\n        });\r\n    }\r\n}\n\nvar FLAGS_STRATEGIES = [\r\n    ['pristine', 'every'],\r\n    ['dirty', 'some'],\r\n    ['touched', 'some'],\r\n    ['untouched', 'every'],\r\n    ['valid', 'every'],\r\n    ['invalid', 'some'],\r\n    ['pending', 'some'],\r\n    ['validated', 'every'],\r\n    ['changed', 'some'],\r\n    ['passed', 'every'],\r\n    ['failed', 'some']\r\n];\r\nvar OBSERVER_COUNTER = 0;\r\nfunction data$1() {\r\n    var refs = {};\r\n    var errors = {};\r\n    var flags = createObserverFlags();\r\n    var fields = {};\r\n    // FIXME: Not sure of this one can be typed, circular type reference.\r\n    var observers = [];\r\n    return {\r\n        id: '',\r\n        refs: refs,\r\n        observers: observers,\r\n        errors: errors,\r\n        flags: flags,\r\n        fields: fields\r\n    };\r\n}\r\nfunction provideSelf() {\r\n    return {\r\n        $_veeObserver: this\r\n    };\r\n}\r\nvar ValidationObserver = vue__WEBPACK_IMPORTED_MODULE_0__[\"default\"].extend({\r\n    name: 'ValidationObserver',\r\n    provide: provideSelf,\r\n    inject: {\r\n        $_veeObserver: {\r\n            from: '$_veeObserver',\r\n            default: function () {\r\n                if (!this.$vnode.context.$_veeObserver) {\r\n                    return null;\r\n                }\r\n                return this.$vnode.context.$_veeObserver;\r\n            }\r\n        }\r\n    },\r\n    props: {\r\n        tag: {\r\n            type: String,\r\n            default: 'span'\r\n        },\r\n        vid: {\r\n            type: String,\r\n            default: function () {\r\n                return \"obs_\" + OBSERVER_COUNTER++;\r\n            }\r\n        },\r\n        slim: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        disabled: {\r\n            type: Boolean,\r\n            default: false\r\n        }\r\n    },\r\n    data: data$1,\r\n    created: function () {\r\n        var _this = this;\r\n        this.id = this.vid;\r\n        register(this);\r\n        var onChange = debounce(function (_a) {\r\n            var errors = _a.errors, flags = _a.flags, fields = _a.fields;\r\n            _this.errors = errors;\r\n            _this.flags = flags;\r\n            _this.fields = fields;\r\n        }, 16);\r\n        this.$watch(computeObserverState, onChange);\r\n    },\r\n    activated: function () {\r\n        register(this);\r\n    },\r\n    deactivated: function () {\r\n        unregister(this);\r\n    },\r\n    beforeDestroy: function () {\r\n        unregister(this);\r\n    },\r\n    render: function (h) {\r\n        var children = normalizeChildren(this, prepareSlotProps(this));\r\n        return this.slim && children.length <= 1 ? children[0] : h(this.tag, { on: this.$listeners }, children);\r\n    },\r\n    methods: {\r\n        observe: function (subscriber, kind) {\r\n            var _a;\r\n            if (kind === void 0) { kind = 'provider'; }\r\n            if (kind === 'observer') {\r\n                this.observers.push(subscriber);\r\n                return;\r\n            }\r\n            this.refs = __assign(__assign({}, this.refs), (_a = {}, _a[subscriber.id] = subscriber, _a));\r\n        },\r\n        unobserve: function (id, kind) {\r\n            if (kind === void 0) { kind = 'provider'; }\r\n            if (kind === 'provider') {\r\n                var provider = this.refs[id];\r\n                if (!provider) {\r\n                    return;\r\n                }\r\n                this.$delete(this.refs, id);\r\n                return;\r\n            }\r\n            var idx = findIndex(this.observers, function (o) { return o.id === id; });\r\n            if (idx !== -1) {\r\n                this.observers.splice(idx, 1);\r\n            }\r\n        },\r\n        validate: function (_a) {\r\n            var _b = (_a === void 0 ? {} : _a).silent, silent = _b === void 0 ? false : _b;\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var results;\r\n                return __generator(this, function (_c) {\r\n                    switch (_c.label) {\r\n                        case 0: return [4 /*yield*/, Promise.all(__spreadArrays(values(this.refs)\r\n                                .filter(function (r) { return !r.disabled; })\r\n                                .map(function (ref) { return ref[silent ? 'validateSilent' : 'validate']().then(function (r) { return r.valid; }); }), this.observers.filter(function (o) { return !o.disabled; }).map(function (obs) { return obs.validate({ silent: silent }); })))];\r\n                        case 1:\r\n                            results = _c.sent();\r\n                            return [2 /*return*/, results.every(function (r) { return r; })];\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        handleSubmit: function (cb) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var isValid;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0: return [4 /*yield*/, this.validate()];\r\n                        case 1:\r\n                            isValid = _a.sent();\r\n                            if (!isValid || !cb) {\r\n                                return [2 /*return*/];\r\n                            }\r\n                            return [2 /*return*/, cb()];\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        reset: function () {\r\n            return __spreadArrays(values(this.refs), this.observers).forEach(function (ref) { return ref.reset(); });\r\n        },\r\n        setErrors: function (errors) {\r\n            var _this = this;\r\n            Object.keys(errors).forEach(function (key) {\r\n                var provider = _this.refs[key];\r\n                if (!provider)\r\n                    return;\r\n                var errorArr = errors[key] || [];\r\n                errorArr = typeof errorArr === 'string' ? [errorArr] : errorArr;\r\n                provider.setErrors(errorArr);\r\n            });\r\n            this.observers.forEach(function (observer) {\r\n                observer.setErrors(errors);\r\n            });\r\n        }\r\n    }\r\n});\r\nfunction unregister(vm) {\r\n    if (vm.$_veeObserver) {\r\n        vm.$_veeObserver.unobserve(vm.id, 'observer');\r\n    }\r\n}\r\nfunction register(vm) {\r\n    if (vm.$_veeObserver) {\r\n        vm.$_veeObserver.observe(vm, 'observer');\r\n    }\r\n}\r\nfunction prepareSlotProps(vm) {\r\n    return __assign(__assign({}, vm.flags), { errors: vm.errors, fields: vm.fields, validate: vm.validate, passes: vm.handleSubmit, handleSubmit: vm.handleSubmit, reset: vm.reset });\r\n}\r\n// Creates a modified version of validation flags\r\nfunction createObserverFlags() {\r\n    return __assign(__assign({}, createFlags()), { valid: true, invalid: false });\r\n}\r\nfunction computeObserverState() {\r\n    var vms = __spreadArrays(values(this.refs), this.observers);\r\n    var errors = {};\r\n    var flags = createObserverFlags();\r\n    var fields = {};\r\n    var length = vms.length;\r\n    for (var i = 0; i < length; i++) {\r\n        var vm = vms[i];\r\n        // validation provider\r\n        if (Array.isArray(vm.errors)) {\r\n            errors[vm.id] = vm.errors;\r\n            fields[vm.id] = __assign({ id: vm.id, name: vm.name, failedRules: vm.failedRules }, vm.flags);\r\n            continue;\r\n        }\r\n        // Nested observer, merge errors and fields\r\n        errors = __assign(__assign({}, errors), vm.errors);\r\n        fields = __assign(__assign({}, fields), vm.fields);\r\n    }\r\n    FLAGS_STRATEGIES.forEach(function (_a) {\r\n        var flag = _a[0], method = _a[1];\r\n        flags[flag] = vms[method](function (vm) { return vm.flags[flag]; });\r\n    });\r\n    return { errors: errors, flags: flags, fields: fields };\r\n}\n\nfunction withValidation(component, mapProps) {\r\n    if (mapProps === void 0) { mapProps = identity; }\r\n    var _a, _b;\r\n    var options = 'options' in component ? component.options : component;\r\n    var providerOpts = ValidationProvider.options;\r\n    var hoc = {\r\n        name: (options.name || 'AnonymousHoc') + \"WithValidation\",\r\n        props: __assign({}, providerOpts.props),\r\n        data: providerOpts.data,\r\n        computed: __assign({}, providerOpts.computed),\r\n        methods: __assign({}, providerOpts.methods),\r\n        beforeDestroy: providerOpts.beforeDestroy,\r\n        inject: providerOpts.inject\r\n    };\r\n    var eventName = ((_b = (_a = options) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.event) || 'input';\r\n    hoc.render = function (h) {\r\n        var _a;\r\n        var _b, _c;\r\n        this.registerField();\r\n        var vctx = createValidationCtx(this);\r\n        var listeners = __assign({}, this.$listeners);\r\n        var model = findModel(this.$vnode);\r\n        this._inputEventName = this._inputEventName || getInputEventName(this.$vnode, model);\r\n        var value = findValue(this.$vnode);\r\n        onRenderUpdate(this, (_b = value) === null || _b === void 0 ? void 0 : _b.value);\r\n        var _d = createCommonHandlers(this), onInput = _d.onInput, onBlur = _d.onBlur, onValidate = _d.onValidate;\r\n        mergeVNodeListeners(listeners, eventName, onInput);\r\n        mergeVNodeListeners(listeners, 'blur', onBlur);\r\n        this.normalizedEvents.forEach(function (evt) {\r\n            mergeVNodeListeners(listeners, evt, onValidate);\r\n        });\r\n        // Props are any attrs not associated with ValidationProvider Plus the model prop.\r\n        // WARNING: Accidental prop overwrite will probably happen.\r\n        var prop = (findModelConfig(this.$vnode) || { prop: 'value' }).prop;\r\n        var props = __assign(__assign(__assign({}, this.$attrs), (_a = {}, _a[prop] = (_c = model) === null || _c === void 0 ? void 0 : _c.value, _a)), mapProps(vctx));\r\n        return h(options, {\r\n            attrs: this.$attrs,\r\n            props: props,\r\n            on: listeners\r\n        }, normalizeSlots(this.$slots, this.$vnode.context));\r\n    };\r\n    return hoc;\r\n}\n\nvar version = '3.2.5';\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdmVlLXZhbGlkYXRlL2Rpc3QvdmVlLXZhbGlkYXRlLmVzbS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92ZWUtdmFsaWRhdGUvZGlzdC92ZWUtdmFsaWRhdGUuZXNtLmpzPzdiYjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gICogdmVlLXZhbGlkYXRlIHYzLjIuNVxuICAqIChjKSAyMDIwIEFiZGVscmFobWFuIEF3YWRcbiAgKiBAbGljZW5zZSBNSVRcbiAgKi9cbmltcG9ydCBWdWUgZnJvbSAndnVlJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpOyB5b3UgbWF5IG5vdCB1c2VcclxudGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuTGljZW5zZSBhdCBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblRISVMgQ09ERSBJUyBQUk9WSURFRCBPTiBBTiAqQVMgSVMqIEJBU0lTLCBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTllcclxuS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG5XQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgVElUTEUsIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLFxyXG5NRVJDSEFOVEFCTElUWSBPUiBOT04tSU5GUklOR0VNRU5ULlxyXG5cclxuU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbmFuZCBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cblxuZnVuY3Rpb24gaXNOYU4odmFsdWUpIHtcclxuICAgIC8vIE5hTiBpcyB0aGUgb25lIHZhbHVlIHRoYXQgZG9lcyBub3QgZXF1YWwgaXRzZWxmLlxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xyXG59XHJcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkoYXJyKSB7XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcnIpICYmIGFyci5sZW5ndGggPT09IDA7XHJcbn1cclxudmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBvYmogJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqKTtcclxufTtcclxuLyoqXHJcbiAqIFNoYWxsb3cgb2JqZWN0IGNvbXBhcmlzb24uXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0VxdWFsKGxocywgcmhzKSB7XHJcbiAgICBpZiAobGhzIGluc3RhbmNlb2YgUmVnRXhwICYmIHJocyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xyXG4gICAgICAgIHJldHVybiBpc0VxdWFsKGxocy5zb3VyY2UsIHJocy5zb3VyY2UpICYmIGlzRXF1YWwobGhzLmZsYWdzLCByaHMuZmxhZ3MpO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkobGhzKSAmJiBBcnJheS5pc0FycmF5KHJocykpIHtcclxuICAgICAgICBpZiAobGhzLmxlbmd0aCAhPT0gcmhzLmxlbmd0aClcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChsaHNbaV0sIHJoc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIGlmIGJvdGggYXJlIG9iamVjdHMsIGNvbXBhcmUgZWFjaCBrZXkgcmVjdXJzaXZlbHkuXHJcbiAgICBpZiAoaXNPYmplY3QobGhzKSAmJiBpc09iamVjdChyaHMpKSB7XHJcbiAgICAgICAgcmV0dXJuIChPYmplY3Qua2V5cyhsaHMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRXF1YWwobGhzW2tleV0sIHJoc1trZXldKTtcclxuICAgICAgICB9KSAmJlxyXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhyaHMpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpc0VxdWFsKGxoc1trZXldLCByaHNba2V5XSk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIGlmIChpc05hTihsaHMpICYmIGlzTmFOKHJocykpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBsaHMgPT09IHJocztcclxufVxyXG4vLyBDaGVja3MgaWYgYSBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gZW1wdHkgc3RyaW5nIG9yIG51bGwgb3IgdW5kZWZpbmVkLlxyXG5mdW5jdGlvbiBpc1NwZWNpZmllZCh2YWwpIHtcclxuICAgIGlmICh2YWwgPT09ICcnKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICFpc051bGxPclVuZGVmaW5lZCh2YWwpO1xyXG59XHJcbmZ1bmN0aW9uIGlzQ2FsbGFibGUoZm4pIHtcclxuICAgIHJldHVybiB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZnVuY3Rpb24gaXNMb2NhdG9yKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gaXNDYWxsYWJsZSh2YWx1ZSkgJiYgISF2YWx1ZS5fX2xvY2F0b3JSZWY7XHJcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFycmF5TGlrZSwgcHJlZGljYXRlKSB7XHJcbiAgICB2YXIgYXJyYXkgPSBBcnJheS5pc0FycmF5KGFycmF5TGlrZSkgPyBhcnJheUxpa2UgOiB0b0FycmF5KGFycmF5TGlrZSk7XHJcbiAgICBpZiAoaXNDYWxsYWJsZShhcnJheS5maW5kSW5kZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5LmZpbmRJbmRleChwcmVkaWNhdGUpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2ldLCBpKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIC0xO1xyXG59XHJcbi8qKlxyXG4gKiBmaW5kcyB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IHNhdGlzZmllcyB0aGUgcHJlZGljYXRlIGNhbGxiYWNrLCBwb2x5ZmlsbHMgYXJyYXkuZmluZFxyXG4gKi9cclxuZnVuY3Rpb24gZmluZChhcnJheUxpa2UsIHByZWRpY2F0ZSkge1xyXG4gICAgdmFyIGFycmF5ID0gQXJyYXkuaXNBcnJheShhcnJheUxpa2UpID8gYXJyYXlMaWtlIDogdG9BcnJheShhcnJheUxpa2UpO1xyXG4gICAgdmFyIGlkeCA9IGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlKTtcclxuICAgIHJldHVybiBpZHggPT09IC0xID8gdW5kZWZpbmVkIDogYXJyYXlbaWR4XTtcclxufVxyXG5mdW5jdGlvbiBpbmNsdWRlcyhjb2xsZWN0aW9uLCBpdGVtKSB7XHJcbiAgICByZXR1cm4gY29sbGVjdGlvbi5pbmRleE9mKGl0ZW0pICE9PSAtMTtcclxufVxyXG4vKipcclxuICogQ29udmVydHMgYW4gYXJyYXktbGlrZSBvYmplY3QgdG8gYXJyYXksIHByb3ZpZGVzIGEgc2ltcGxlIHBvbHlmaWxsIGZvciBBcnJheS5mcm9tXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZSkge1xyXG4gICAgaWYgKGlzQ2FsbGFibGUoQXJyYXkuZnJvbSkpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhcnJheUxpa2UpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBfY29weUFycmF5KGFycmF5TGlrZSk7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuZnVuY3Rpb24gX2NvcHlBcnJheShhcnJheUxpa2UpIHtcclxuICAgIHZhciBhcnJheSA9IFtdO1xyXG4gICAgdmFyIGxlbmd0aCA9IGFycmF5TGlrZS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgYXJyYXkucHVzaChhcnJheUxpa2VbaV0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFycmF5O1xyXG59XHJcbmZ1bmN0aW9uIHZhbHVlcyhvYmopIHtcclxuICAgIGlmIChpc0NhbGxhYmxlKE9iamVjdC52YWx1ZXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcclxuICAgIH1cclxuICAgIC8vIGZhbGxiYWNrIHRvIGtleXMoKVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbiAoaykgeyByZXR1cm4gb2JqW2tdOyB9KTtcclxufVxyXG5mdW5jdGlvbiBtZXJnZSh0YXJnZXQsIHNvdXJjZSkge1xyXG4gICAgT2JqZWN0LmtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0W2tleV0pIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbWVyZ2UodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gdGFyZ2V0O1xyXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZsYWdzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1bnRvdWNoZWQ6IHRydWUsXHJcbiAgICAgICAgdG91Y2hlZDogZmFsc2UsXHJcbiAgICAgICAgZGlydHk6IGZhbHNlLFxyXG4gICAgICAgIHByaXN0aW5lOiB0cnVlLFxyXG4gICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICBpbnZhbGlkOiBmYWxzZSxcclxuICAgICAgICB2YWxpZGF0ZWQ6IGZhbHNlLFxyXG4gICAgICAgIHBlbmRpbmc6IGZhbHNlLFxyXG4gICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICBjaGFuZ2VkOiBmYWxzZSxcclxuICAgICAgICBwYXNzZWQ6IGZhbHNlLFxyXG4gICAgICAgIGZhaWxlZDogZmFsc2VcclxuICAgIH07XHJcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xyXG4gICAgcmV0dXJuIHg7XHJcbn1cclxuZnVuY3Rpb24gZGVib3VuY2UoZm4sIHdhaXQsIHRva2VuKSB7XHJcbiAgICBpZiAod2FpdCA9PT0gdm9pZCAwKSB7IHdhaXQgPSAwOyB9XHJcbiAgICBpZiAodG9rZW4gPT09IHZvaWQgMCkgeyB0b2tlbiA9IHsgY2FuY2VsbGVkOiBmYWxzZSB9OyB9XHJcbiAgICBpZiAod2FpdCA9PT0gMCkge1xyXG4gICAgICAgIHJldHVybiBmbjtcclxuICAgIH1cclxuICAgIHZhciB0aW1lb3V0O1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxhdGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aW1lb3V0ID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgZm4gY2FsbCB3YXMgY2FuY2VsbGVkLlxyXG4gICAgICAgICAgICBpZiAoIXRva2VuLmNhbmNlbGxlZClcclxuICAgICAgICAgICAgICAgIGZuLmFwcGx5KHZvaWQgMCwgYXJncyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBiZWNhdXNlIHdlIG1pZ2h0IHdhbnQgdG8gdXNlIE5vZGUuanMgc2V0VGltb3V0IGZvciBTU1IuXHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0KTtcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEVtaXRzIGEgd2FybmluZyB0byB0aGUgY29uc29sZVxyXG4gKi9cclxuZnVuY3Rpb24gd2FybihtZXNzYWdlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJbdmVlLXZhbGlkYXRlXSBcIiArIG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXBsYWNlcyBwbGFjZWhvbGRlciB2YWx1ZXMgaW4gYSBzdHJpbmcgd2l0aCB0aGVpciBhY3R1YWwgdmFsdWVzXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh0ZW1wbGF0ZSwgdmFsdWVzKSB7XHJcbiAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSgveyhbXn1dKyl9L2csIGZ1bmN0aW9uIChfLCBwKSB7XHJcbiAgICAgICAgcmV0dXJuIHAgaW4gdmFsdWVzID8gdmFsdWVzW3BdIDogXCJ7XCIgKyBwICsgXCJ9XCI7XHJcbiAgICB9KTtcclxufVxuXG52YXIgUlVMRVMgPSB7fTtcclxuZnVuY3Rpb24gbm9ybWFsaXplU2NoZW1hKHNjaGVtYSkge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgaWYgKChfYSA9IHNjaGVtYS5wYXJhbXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcclxuICAgICAgICBzY2hlbWEucGFyYW1zID0gc2NoZW1hLnBhcmFtcy5tYXAoZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBuYW1lOiBwYXJhbSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJhbTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBzY2hlbWE7XHJcbn1cclxudmFyIFJ1bGVDb250YWluZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBSdWxlQ29udGFpbmVyKCkge1xyXG4gICAgfVxyXG4gICAgUnVsZUNvbnRhaW5lci5leHRlbmQgPSBmdW5jdGlvbiAobmFtZSwgc2NoZW1hKSB7XHJcbiAgICAgICAgLy8gaWYgcnVsZSBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0LlxyXG4gICAgICAgIHZhciBydWxlID0gbm9ybWFsaXplU2NoZW1hKHNjaGVtYSk7XHJcbiAgICAgICAgaWYgKFJVTEVTW25hbWVdKSB7XHJcbiAgICAgICAgICAgIFJVTEVTW25hbWVdID0gbWVyZ2UoUlVMRVNbbmFtZV0sIHNjaGVtYSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgUlVMRVNbbmFtZV0gPSBfX2Fzc2lnbih7IGxhenk6IGZhbHNlLCBjb21wdXRlc1JlcXVpcmVkOiBmYWxzZSB9LCBydWxlKTtcclxuICAgIH07XHJcbiAgICBSdWxlQ29udGFpbmVyLmlzTGF6eSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAhISgoX2EgPSBSVUxFU1tuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhenkpO1xyXG4gICAgfTtcclxuICAgIFJ1bGVDb250YWluZXIuaXNSZXF1aXJlUnVsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAhISgoX2EgPSBSVUxFU1tuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbXB1dGVzUmVxdWlyZWQpO1xyXG4gICAgfTtcclxuICAgIFJ1bGVDb250YWluZXIuZ2V0UnVsZURlZmluaXRpb24gPSBmdW5jdGlvbiAocnVsZU5hbWUpIHtcclxuICAgICAgICByZXR1cm4gUlVMRVNbcnVsZU5hbWVdO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSdWxlQ29udGFpbmVyO1xyXG59KCkpO1xyXG4vKipcclxuICogQWRkcyBhIGN1c3RvbSB2YWxpZGF0b3IgdG8gdGhlIGxpc3Qgb2YgdmFsaWRhdGlvbiBydWxlcy5cclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZChuYW1lLCBzY2hlbWEpIHtcclxuICAgIC8vIG1ha2VzIHN1cmUgbmV3IHJ1bGVzIGFyZSBwcm9wZXJseSBmb3JtYXR0ZWQuXHJcbiAgICBndWFyZEV4dGVuZChuYW1lLCBzY2hlbWEpO1xyXG4gICAgLy8gRnVsbCBzY2hlbWEgb2JqZWN0LlxyXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgUnVsZUNvbnRhaW5lci5leHRlbmQobmFtZSwgc2NoZW1hKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBSdWxlQ29udGFpbmVyLmV4dGVuZChuYW1lLCB7XHJcbiAgICAgICAgdmFsaWRhdGU6IHNjaGVtYVxyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEd1YXJkcyBmcm9tIGV4dGVuc2lvbiB2aW9sYXRpb25zLlxyXG4gKi9cclxuZnVuY3Rpb24gZ3VhcmRFeHRlbmQobmFtZSwgdmFsaWRhdG9yKSB7XHJcbiAgICBpZiAoaXNDYWxsYWJsZSh2YWxpZGF0b3IpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ2FsbGFibGUodmFsaWRhdG9yLnZhbGlkYXRlKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmIChSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5zaW9uIEVycm9yOiBUaGUgdmFsaWRhdG9yICdcIiArIG5hbWUgKyBcIicgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGhhdmUgYSAndmFsaWRhdGUnIG1ldGhvZC5cIik7XHJcbn1cblxudmFyIERFRkFVTFRfQ09ORklHID0ge1xyXG4gICAgZGVmYXVsdE1lc3NhZ2U6IFwie19maWVsZF99IGlzIG5vdCB2YWxpZC5cIixcclxuICAgIHNraXBPcHRpb25hbDogdHJ1ZSxcclxuICAgIGNsYXNzZXM6IHtcclxuICAgICAgICB0b3VjaGVkOiAndG91Y2hlZCcsXHJcbiAgICAgICAgdW50b3VjaGVkOiAndW50b3VjaGVkJyxcclxuICAgICAgICB2YWxpZDogJ3ZhbGlkJyxcclxuICAgICAgICBpbnZhbGlkOiAnaW52YWxpZCcsXHJcbiAgICAgICAgcHJpc3RpbmU6ICdwcmlzdGluZScsXHJcbiAgICAgICAgZGlydHk6ICdkaXJ0eScgLy8gY29udHJvbCBoYXMgYmVlbiBpbnRlcmFjdGVkIHdpdGhcclxuICAgIH0sXHJcbiAgICBiYWlsczogdHJ1ZSxcclxuICAgIG1vZGU6ICdhZ2dyZXNzaXZlJyxcclxuICAgIHVzZUNvbnN0cmFpbnRBdHRyczogdHJ1ZVxyXG59O1xyXG52YXIgY3VycmVudENvbmZpZyA9IF9fYXNzaWduKHt9LCBERUZBVUxUX0NPTkZJRyk7XHJcbnZhciBnZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjdXJyZW50Q29uZmlnOyB9O1xyXG52YXIgc2V0Q29uZmlnID0gZnVuY3Rpb24gKG5ld0NvbmYpIHtcclxuICAgIGN1cnJlbnRDb25maWcgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgY3VycmVudENvbmZpZyksIG5ld0NvbmYpO1xyXG59O1xyXG52YXIgY29uZmlndXJlID0gZnVuY3Rpb24gKGNmZykge1xyXG4gICAgc2V0Q29uZmlnKGNmZyk7XHJcbn07XG5cbi8qKlxyXG4gKiBOb3JtYWxpemVzIHRoZSBnaXZlbiBydWxlcyBleHByZXNzaW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gbm9ybWFsaXplUnVsZXMocnVsZXMpIHtcclxuICAgIC8vIGlmIGZhbHN5IHZhbHVlIHJldHVybiBhbiBlbXB0eSBvYmplY3QuXHJcbiAgICB2YXIgYWNjID0ge307XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYWNjLCAnXyQkaXNOb3JtYWxpemVkJywge1xyXG4gICAgICAgIHZhbHVlOiB0cnVlLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgfVxyXG4gICAgLy8gT2JqZWN0IGlzIGFscmVhZHkgbm9ybWFsaXplZCwgc2tpcC5cclxuICAgIGlmIChpc09iamVjdChydWxlcykgJiYgcnVsZXMuXyQkaXNOb3JtYWxpemVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzT2JqZWN0KHJ1bGVzKSkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhydWxlcykucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzW2N1cnJdID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJ1bGVzW2N1cnJdKSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gcnVsZXNbY3Vycl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QocnVsZXNbY3Vycl0pKSB7XHJcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBydWxlc1tjdXJyXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBhcmFtcyA9IFtydWxlc1tjdXJyXV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHJ1bGVzW2N1cnJdICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgcHJldltjdXJyXSA9IGJ1aWxkUGFyYW1zKGN1cnIsIHBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHByZXY7XHJcbiAgICAgICAgfSwgYWNjKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgaWYgKHR5cGVvZiBydWxlcyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICB3YXJuKCdydWxlcyBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBvYmplY3QuJyk7XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgIH1cclxuICAgIHJldHVybiBydWxlcy5zcGxpdCgnfCcpLnJlZHVjZShmdW5jdGlvbiAocHJldiwgcnVsZSkge1xyXG4gICAgICAgIHZhciBwYXJzZWRSdWxlID0gcGFyc2VSdWxlKHJ1bGUpO1xyXG4gICAgICAgIGlmICghcGFyc2VkUnVsZS5uYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwcmV2O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwcmV2W3BhcnNlZFJ1bGUubmFtZV0gPSBidWlsZFBhcmFtcyhwYXJzZWRSdWxlLm5hbWUsIHBhcnNlZFJ1bGUucGFyYW1zKTtcclxuICAgICAgICByZXR1cm4gcHJldjtcclxuICAgIH0sIGFjYyk7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRQYXJhbXMocnVsZU5hbWUsIHByb3ZpZGVkKSB7XHJcbiAgICB2YXIgcnVsZVNjaGVtYSA9IFJ1bGVDb250YWluZXIuZ2V0UnVsZURlZmluaXRpb24ocnVsZU5hbWUpO1xyXG4gICAgaWYgKCFydWxlU2NoZW1hKSB7XHJcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVkO1xyXG4gICAgfVxyXG4gICAgdmFyIHBhcmFtcyA9IHt9O1xyXG4gICAgaWYgKCFydWxlU2NoZW1hLnBhcmFtcyAmJiAhQXJyYXkuaXNBcnJheShwcm92aWRlZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhbiBvYmplY3QgcGFyYW1zIHRvIGEgcnVsZSB0aGF0IGhhcyBubyBkZWZpbmVkIHNjaGVtYS4nKTtcclxuICAgIH1cclxuICAgIC8vIFJ1bGUgcHJvYmFibHkgdXNlcyBhbiBhcnJheSBmb3IgdGhlaXIgYXJncywga2VlcCBpdCBhcyBpcy5cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ZpZGVkKSAmJiAhcnVsZVNjaGVtYS5wYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gcHJvdmlkZWQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZGVmaW5lZFBhcmFtcztcclxuICAgIC8vIGNvbGxlY3QgdGhlIHBhcmFtcyBzY2hlbWEuXHJcbiAgICBpZiAoIXJ1bGVTY2hlbWEucGFyYW1zIHx8IChydWxlU2NoZW1hLnBhcmFtcy5sZW5ndGggPCBwcm92aWRlZC5sZW5ndGggJiYgQXJyYXkuaXNBcnJheShwcm92aWRlZCkpKSB7XHJcbiAgICAgICAgdmFyIGxhc3REZWZpbmVkUGFyYW1fMTtcclxuICAgICAgICAvLyBjb2xsZWN0IGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgaW4gdGhlIGxhc3QgaXRlbS5cclxuICAgICAgICBkZWZpbmVkUGFyYW1zID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIChfLCBpZHgpIHtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICB2YXIgcGFyYW0gPSAoX2EgPSBydWxlU2NoZW1hLnBhcmFtcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2lkeF07XHJcbiAgICAgICAgICAgIGxhc3REZWZpbmVkUGFyYW1fMSA9IHBhcmFtIHx8IGxhc3REZWZpbmVkUGFyYW1fMTtcclxuICAgICAgICAgICAgaWYgKCFwYXJhbSkge1xyXG4gICAgICAgICAgICAgICAgcGFyYW0gPSBsYXN0RGVmaW5lZFBhcmFtXzE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVmaW5lZFBhcmFtcyA9IHJ1bGVTY2hlbWEucGFyYW1zO1xyXG4gICAgfVxyXG4gICAgLy8gTWF0Y2ggdGhlIHByb3ZpZGVkIGFycmF5IGxlbmd0aCB3aXRoIGEgdGVtcG9yYXJ5IHNjaGVtYS5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVmaW5lZFBhcmFtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBvcHRpb25zID0gZGVmaW5lZFBhcmFtc1tpXTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zLmRlZmF1bHQ7XHJcbiAgICAgICAgLy8gaWYgdGhlIHByb3ZpZGVkIGlzIGFuIGFycmF5LCBtYXAgZWxlbWVudCB2YWx1ZS5cclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm92aWRlZCkpIHtcclxuICAgICAgICAgICAgaWYgKGkgaW4gcHJvdmlkZWQpIHtcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcHJvdmlkZWRbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwYXJhbSBleGlzdHMgaW4gdGhlIHByb3ZpZGVkIG9iamVjdC5cclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMubmFtZSBpbiBwcm92aWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwcm92aWRlZFtvcHRpb25zLm5hbWVdO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByb3ZpZGVkIGlzIHRoZSBmaXJzdCBwYXJhbSB2YWx1ZS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkZWZpbmVkUGFyYW1zLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwcm92aWRlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgcGFyYW0gaXMgYSB0YXJnZXQsIHJlc29sdmUgdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgICAgICBpZiAob3B0aW9ucy5pc1RhcmdldCkge1xyXG4gICAgICAgICAgICB2YWx1ZSA9IGNyZWF0ZUxvY2F0b3IodmFsdWUsIG9wdGlvbnMuY2FzdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEEgdGFyZ2V0IHBhcmFtIHVzaW5nIGludGVycG9sYXRpb25cclxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZVswXSA9PT0gJ0AnKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gY3JlYXRlTG9jYXRvcih2YWx1ZS5zbGljZSgxKSwgb3B0aW9ucy5jYXN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSB0cmFuc2Zvcm1lciBkZWZpbmVkLlxyXG4gICAgICAgIGlmICghaXNMb2NhdG9yKHZhbHVlKSAmJiBvcHRpb25zLmNhc3QpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBvcHRpb25zLmNhc3QodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhbHJlYWR5IGJlZW4gc2V0LCBwcm9iYWJseSBtdWx0aXBsZSB2YWx1ZXMuXHJcbiAgICAgICAgaWYgKHBhcmFtc1tvcHRpb25zLm5hbWVdKSB7XHJcbiAgICAgICAgICAgIHBhcmFtc1tvcHRpb25zLm5hbWVdID0gQXJyYXkuaXNBcnJheShwYXJhbXNbb3B0aW9ucy5uYW1lXSkgPyBwYXJhbXNbb3B0aW9ucy5uYW1lXSA6IFtwYXJhbXNbb3B0aW9ucy5uYW1lXV07XHJcbiAgICAgICAgICAgIHBhcmFtc1tvcHRpb25zLm5hbWVdLnB1c2godmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gc2V0IHRoZSB2YWx1ZS5cclxuICAgICAgICAgICAgcGFyYW1zW29wdGlvbnMubmFtZV0gPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFyYW1zO1xyXG59XHJcbi8qKlxyXG4gKiBQYXJzZXMgYSBydWxlIHN0cmluZyBleHByZXNzaW9uLlxyXG4gKi9cclxudmFyIHBhcnNlUnVsZSA9IGZ1bmN0aW9uIChydWxlKSB7XHJcbiAgICB2YXIgcGFyYW1zID0gW107XHJcbiAgICB2YXIgbmFtZSA9IHJ1bGUuc3BsaXQoJzonKVswXTtcclxuICAgIGlmIChpbmNsdWRlcyhydWxlLCAnOicpKSB7XHJcbiAgICAgICAgcGFyYW1zID0gcnVsZVxyXG4gICAgICAgICAgICAuc3BsaXQoJzonKVxyXG4gICAgICAgICAgICAuc2xpY2UoMSlcclxuICAgICAgICAgICAgLmpvaW4oJzonKVxyXG4gICAgICAgICAgICAuc3BsaXQoJywnKTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG5hbWU6IG5hbWUsIHBhcmFtczogcGFyYW1zIH07XHJcbn07XHJcbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0b3IodmFsdWUsIGNhc3RGbikge1xyXG4gICAgdmFyIGxvY2F0b3IgPSBmdW5jdGlvbiAoY3Jvc3NUYWJsZSkge1xyXG4gICAgICAgIHZhciB2YWwgPSBjcm9zc1RhYmxlW3ZhbHVlXTtcclxuICAgICAgICByZXR1cm4gY2FzdEZuID8gY2FzdEZuKHZhbCkgOiB2YWw7XHJcbiAgICB9O1xyXG4gICAgbG9jYXRvci5fX2xvY2F0b3JSZWYgPSB2YWx1ZTtcclxuICAgIHJldHVybiBsb2NhdG9yO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RMb2NhdG9ycyhwYXJhbXMpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcclxuICAgICAgICByZXR1cm4gcGFyYW1zLmZpbHRlcihpc0xvY2F0b3IpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHBhcmFtcylcclxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGlzTG9jYXRvcihwYXJhbXNba2V5XSk7IH0pXHJcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwYXJhbXNba2V5XTsgfSk7XHJcbn1cblxuLyoqXHJcbiAqIFZhbGlkYXRlcyBhIHZhbHVlIGFnYWluc3QgdGhlIHJ1bGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHJ1bGVzLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHNob3VsZEJhaWwsIHNraXBJZkVtcHR5LCBmaWVsZCwgcmVzdWx0LCBlcnJvcnMsIGZhaWxlZFJ1bGVzLCByZWdlbmVyYXRlTWFwO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2cpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfZy5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZEJhaWwgPSAoX2EgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmFpbHM7XHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcElmRW1wdHkgPSAoX2IgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2tpcElmRW1wdHk7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICgoX2MgPSBvcHRpb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MubmFtZSkgfHwgJ3tmaWVsZH0nLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlczogbm9ybWFsaXplUnVsZXMocnVsZXMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBiYWlsczogKHNob3VsZEJhaWwgIT09IG51bGwgJiYgc2hvdWxkQmFpbCAhPT0gdm9pZCAwID8gc2hvdWxkQmFpbCA6IHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwSWZFbXB0eTogKHNraXBJZkVtcHR5ICE9PSBudWxsICYmIHNraXBJZkVtcHR5ICE9PSB2b2lkIDAgPyBza2lwSWZFbXB0eSA6IHRydWUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZVJlcXVpcmVkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3Jvc3NUYWJsZTogKChfZCA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52YWx1ZXMpIHx8IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lczogKChfZSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5uYW1lcykgfHwge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbU1lc3NhZ2VzOiAoKF9mID0gb3B0aW9ucykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmN1c3RvbU1lc3NhZ2VzKSB8fCB7fVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX3ZhbGlkYXRlKGZpZWxkLCB2YWx1ZSwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9nLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmYWlsZWRSdWxlcyA9IHt9O1xyXG4gICAgICAgICAgICAgICAgICAgIHJlZ2VuZXJhdGVNYXAgPSB7fTtcclxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1zZyA9IGUubXNnKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKG1zZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhaWxlZFJ1bGVzW2UucnVsZV0gPSBtc2c7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2VuZXJhdGVNYXBbZS5ydWxlXSA9IGUubXNnO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogcmVzdWx0LnZhbGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWlsZWRSdWxlczogZmFpbGVkUnVsZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWdlbmVyYXRlTWFwOiByZWdlbmVyYXRlTWFwXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogU3RhcnRzIHRoZSB2YWxpZGF0aW9uIHByb2Nlc3MuXHJcbiAqL1xyXG5mdW5jdGlvbiBfdmFsaWRhdGUoZmllbGQsIHZhbHVlLCBfYSkge1xyXG4gICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5pc0luaXRpYWwsIGlzSW5pdGlhbCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYywgc2hvdWxkU2tpcCwgZXJyb3JzLCBydWxlcywgbGVuZ3RoLCBpLCBydWxlLCByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZCkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9kLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIF9zaG91bGRTa2lwKGZpZWxkLCB2YWx1ZSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2Quc2VudCgpLCBzaG91bGRTa2lwID0gX2Muc2hvdWxkU2tpcCwgZXJyb3JzID0gX2MuZXJyb3JzO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTa2lwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6ICFlcnJvcnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZXMgPSBPYmplY3Qua2V5cyhmaWVsZC5ydWxlcykuZmlsdGVyKGZ1bmN0aW9uIChydWxlKSB7IHJldHVybiAhUnVsZUNvbnRhaW5lci5pc1JlcXVpcmVSdWxlKHJ1bGUpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBydWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSAyO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBsZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsICYmIFJ1bGVDb250YWluZXIuaXNMYXp5KHJ1bGVzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcnVsZSA9IHJ1bGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIF90ZXN0KGZpZWxkLCB2YWx1ZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogcnVsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogZmllbGQucnVsZXNbcnVsZV1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9kLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCAmJiByZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVzdWx0LmVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkLmJhaWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2QubGFiZWwgPSA0O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAyXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWQ6ICFlcnJvcnMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgIH1dO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBfc2hvdWxkU2tpcChmaWVsZCwgdmFsdWUpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVxdWlyZVJ1bGVzLCBsZW5ndGgsIGVycm9ycywgaXNFbXB0eSwgaXNFbXB0eUFuZE9wdGlvbmFsLCBpc1JlcXVpcmVkLCBpLCBydWxlLCByZXN1bHQ7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZVJ1bGVzID0gT2JqZWN0LmtleXMoZmllbGQucnVsZXMpLmZpbHRlcihSdWxlQ29udGFpbmVyLmlzUmVxdWlyZVJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IHJlcXVpcmVSdWxlcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgaXNFbXB0eSA9IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCB2YWx1ZSA9PT0gJycgfHwgaXNFbXB0eUFycmF5KHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5QW5kT3B0aW9uYWwgPSBpc0VtcHR5ICYmIGZpZWxkLnNraXBJZkVtcHR5O1xyXG4gICAgICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoaSA8IGxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGUgPSByZXF1aXJlUnVsZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgX3Rlc3QoZmllbGQsIHZhbHVlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBydWxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBmaWVsZC5ydWxlc1tydWxlXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVpcmUgcnVsZXMgaGFzIHRvIHJldHVybiBhbiBvYmplY3QgKHNlZSBkb2NzKScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlcXVpcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzUmVxdWlyZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC52YWxpZCAmJiByZXN1bHQuZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2gocmVzdWx0LmVycm9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBhcyB0aGUgZmllbGQgaXMgcmVxdWlyZWQgYW5kIGZhaWxlZCB2YWxpZGF0aW9uLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuYmFpbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFNraXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogZXJyb3JzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgIGkrKztcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eSAmJiAhaXNSZXF1aXJlZCAmJiAhZmllbGQuc2tpcElmRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTa2lwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGZpZWxkIGlzIGNvbmZpZ3VyZWQgdG8gcnVuIHRocm91Z2ggdGhlIHBpcGVsaW5lIHJlZ2FyZGxlc3NcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWZpZWxkLmJhaWxzICYmICFpc0VtcHR5QW5kT3B0aW9uYWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTa2lwOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdGhlIGZpZWxkIGlzIG5vdCByZXF1aXJlZCBhbmQgaGFzIGFuIGVtcHR5IHZhbHVlLlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRTa2lwOiAhaXNSZXF1aXJlZCAmJiBpc0VtcHR5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBUZXN0cyBhIHNpbmdsZSBpbnB1dCB2YWx1ZSBhZ2FpbnN0IGEgcnVsZS5cclxuICovXHJcbmZ1bmN0aW9uIF90ZXN0KGZpZWxkLCB2YWx1ZSwgcnVsZSkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBydWxlU2NoZW1hLCBub3JtYWxpemVkVmFsdWUsIHBhcmFtcywgcmVzdWx0LCB2YWx1ZXNfMTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBydWxlU2NoZW1hID0gUnVsZUNvbnRhaW5lci5nZXRSdWxlRGVmaW5pdGlvbihydWxlLm5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghcnVsZVNjaGVtYSB8fCAhcnVsZVNjaGVtYS52YWxpZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzdWNoIHZhbGlkYXRvciAnXCIgKyBydWxlLm5hbWUgKyBcIicgZXhpc3RzLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlID0gcnVsZVNjaGVtYS5jYXN0VmFsdWUgPyBydWxlU2NoZW1hLmNhc3RWYWx1ZSh2YWx1ZSkgOiB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBmaWxsVGFyZ2V0VmFsdWVzKHJ1bGUucGFyYW1zLCBmaWVsZC5jcm9zc1RhYmxlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBydWxlU2NoZW1hLnZhbGlkYXRlKG5vcm1hbGl6ZWRWYWx1ZSwgcGFyYW1zKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNfMSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCAocGFyYW1zIHx8IHt9KSksIHsgX2ZpZWxkXzogZmllbGQubmFtZSwgX3ZhbHVlXzogdmFsdWUsIF9ydWxlXzogcnVsZS5uYW1lIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogeyBydWxlOiBydWxlLm5hbWUsIG1zZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW50ZXJwb2xhdGUocmVzdWx0LCB2YWx1ZXNfMSk7IH0gfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPYmplY3QocmVzdWx0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB7IHZhbGlkOiByZXN1bHQgfTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlZDogcmVzdWx0LnJlcXVpcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHJlc3VsdC52YWxpZCA/IHVuZGVmaW5lZCA6IF9nZW5lcmF0ZUZpZWxkRXJyb3IoZmllbGQsIHZhbHVlLCBydWxlU2NoZW1hLCBydWxlLm5hbWUsIHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgfV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZXMgZXJyb3IgbWVzc2FnZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2VuZXJhdGVGaWVsZEVycm9yKGZpZWxkLCB2YWx1ZSwgcnVsZVNjaGVtYSwgcnVsZU5hbWUsIHBhcmFtcykge1xyXG4gICAgdmFyIF9hO1xyXG4gICAgdmFyIG1lc3NhZ2UgPSAoX2EgPSBmaWVsZC5jdXN0b21NZXNzYWdlc1tydWxlTmFtZV0sIChfYSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBydWxlU2NoZW1hLm1lc3NhZ2UpKTtcclxuICAgIHZhciBydWxlVGFyZ2V0cyA9IF9nZXRSdWxlVGFyZ2V0cyhmaWVsZCwgcnVsZVNjaGVtYSwgcnVsZU5hbWUpO1xyXG4gICAgdmFyIF9iID0gX2dldFVzZXJUYXJnZXRzKGZpZWxkLCBydWxlU2NoZW1hLCBydWxlTmFtZSwgbWVzc2FnZSksIHVzZXJUYXJnZXRzID0gX2IudXNlclRhcmdldHMsIHVzZXJNZXNzYWdlID0gX2IudXNlck1lc3NhZ2U7XHJcbiAgICB2YXIgdmFsdWVzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIChwYXJhbXMgfHwge30pKSwgeyBfZmllbGRfOiBmaWVsZC5uYW1lLCBfdmFsdWVfOiB2YWx1ZSwgX3J1bGVfOiBydWxlTmFtZSB9KSwgcnVsZVRhcmdldHMpLCB1c2VyVGFyZ2V0cyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1zZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gX25vcm1hbGl6ZU1lc3NhZ2UodXNlck1lc3NhZ2UgfHwgZ2V0Q29uZmlnKCkuZGVmYXVsdE1lc3NhZ2UsIGZpZWxkLm5hbWUsIHZhbHVlcyk7IH0sXHJcbiAgICAgICAgcnVsZTogcnVsZU5hbWVcclxuICAgIH07XHJcbn1cclxuZnVuY3Rpb24gX2dldFJ1bGVUYXJnZXRzKGZpZWxkLCBydWxlU2NoZW1hLCBydWxlTmFtZSkge1xyXG4gICAgdmFyIHBhcmFtcyA9IHJ1bGVTY2hlbWEucGFyYW1zO1xyXG4gICAgaWYgKCFwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICB2YXIgbnVtVGFyZ2V0cyA9IHBhcmFtcy5maWx0ZXIoZnVuY3Rpb24gKHBhcmFtKSB7IHJldHVybiBwYXJhbS5pc1RhcmdldDsgfSkubGVuZ3RoO1xyXG4gICAgaWYgKG51bVRhcmdldHMgPD0gMCkge1xyXG4gICAgICAgIHJldHVybiB7fTtcclxuICAgIH1cclxuICAgIHZhciBuYW1lcyA9IHt9O1xyXG4gICAgdmFyIHJ1bGVDb25maWcgPSBmaWVsZC5ydWxlc1tydWxlTmFtZV07XHJcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZUNvbmZpZykgJiYgaXNPYmplY3QocnVsZUNvbmZpZykpIHtcclxuICAgICAgICBydWxlQ29uZmlnID0gcGFyYW1zLm1hcChmdW5jdGlvbiAocGFyYW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJ1bGVDb25maWdbcGFyYW0ubmFtZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgcGFyYW1zLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpbmRleF07XHJcbiAgICAgICAgdmFyIGtleSA9IHJ1bGVDb25maWdbaW5kZXhdO1xyXG4gICAgICAgIGlmICghaXNMb2NhdG9yKGtleSkpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleSA9IGtleS5fX2xvY2F0b3JSZWY7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IGZpZWxkLm5hbWVzW2tleV0gfHwga2V5O1xyXG4gICAgICAgIG5hbWVzW3BhcmFtLm5hbWVdID0gbmFtZV8xO1xyXG4gICAgICAgIG5hbWVzW1wiX1wiICsgcGFyYW0ubmFtZSArIFwiX1wiXSA9IGZpZWxkLmNyb3NzVGFibGVba2V5XTtcclxuICAgIH1cclxuICAgIHJldHVybiBuYW1lcztcclxufVxyXG5mdW5jdGlvbiBfZ2V0VXNlclRhcmdldHMoZmllbGQsIHJ1bGVTY2hlbWEsIHJ1bGVOYW1lLCB1c2VyTWVzc2FnZSkge1xyXG4gICAgdmFyIHVzZXJUYXJnZXRzID0ge307XHJcbiAgICB2YXIgcnVsZXMgPSBmaWVsZC5ydWxlc1tydWxlTmFtZV07XHJcbiAgICB2YXIgcGFyYW1zID0gcnVsZVNjaGVtYS5wYXJhbXMgfHwgW107XHJcbiAgICAvLyBlYXJseSByZXR1cm4gaWYgbm8gcnVsZXNcclxuICAgIGlmICghcnVsZXMpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICAvLyBjaGVjayBhbGwgcnVsZXMgdG8gY29udmVydCB0YXJnZXRzXHJcbiAgICBPYmplY3Qua2V5cyhydWxlcykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpbmRleCkge1xyXG4gICAgICAgIC8vIGdldCB0aGUgcnVsZVxyXG4gICAgICAgIHZhciBydWxlID0gcnVsZXNba2V5XTtcclxuICAgICAgICBpZiAoIWlzTG9jYXRvcihydWxlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdldCBhc3NvY2lhdGVkIHBhcmFtZXRlclxyXG4gICAgICAgIHZhciBwYXJhbSA9IHBhcmFtc1tpbmRleF07XHJcbiAgICAgICAgaWYgKCFwYXJhbSkge1xyXG4gICAgICAgICAgICByZXR1cm4ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGdyYWIgdGhlIG5hbWUgb2YgdGhlIHRhcmdldFxyXG4gICAgICAgIHZhciBuYW1lID0gcnVsZS5fX2xvY2F0b3JSZWY7XHJcbiAgICAgICAgdXNlclRhcmdldHNbcGFyYW0ubmFtZV0gPSBmaWVsZC5uYW1lc1tuYW1lXSB8fCBuYW1lO1xyXG4gICAgICAgIHVzZXJUYXJnZXRzW1wiX1wiICsgcGFyYW0ubmFtZSArIFwiX1wiXSA9IGZpZWxkLmNyb3NzVGFibGVbbmFtZV07XHJcbiAgICB9KTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlclRhcmdldHM6IHVzZXJUYXJnZXRzLFxyXG4gICAgICAgIHVzZXJNZXNzYWdlOiB1c2VyTWVzc2FnZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBfbm9ybWFsaXplTWVzc2FnZSh0ZW1wbGF0ZSwgZmllbGQsIHZhbHVlcykge1xyXG4gICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZShmaWVsZCwgdmFsdWVzKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnRlcnBvbGF0ZSh0ZW1wbGF0ZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHZhbHVlcyksIHsgX2ZpZWxkXzogZmllbGQgfSkpO1xyXG59XHJcbmZ1bmN0aW9uIGZpbGxUYXJnZXRWYWx1ZXMocGFyYW1zLCBjcm9zc1RhYmxlKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XHJcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcclxuICAgIH1cclxuICAgIHZhciB2YWx1ZXMgPSB7fTtcclxuICAgIHZhciBub3JtYWxpemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICBpZiAoaXNMb2NhdG9yKHZhbHVlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUoY3Jvc3NUYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtKSB7XHJcbiAgICAgICAgdmFsdWVzW3BhcmFtXSA9IG5vcm1hbGl6ZShwYXJhbXNbcGFyYW1dKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHZhbHVlcztcclxufVxuXG52YXIgYWdncmVzc2l2ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XHJcbiAgICBvbjogWydpbnB1dCcsICdibHVyJ11cclxufSk7IH07XHJcbnZhciBsYXp5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcclxuICAgIG9uOiBbJ2NoYW5nZSddXHJcbn0pOyB9O1xyXG52YXIgZWFnZXIgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBlcnJvcnMgPSBfYS5lcnJvcnM7XHJcbiAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9uOiBbJ2lucHV0JywgJ2NoYW5nZSddXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgb246IFsnY2hhbmdlJywgJ2JsdXInXVxyXG4gICAgfTtcclxufTtcclxudmFyIHBhc3NpdmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xyXG4gICAgb246IFtdXHJcbn0pOyB9O1xyXG52YXIgbW9kZXMgPSB7XHJcbiAgICBhZ2dyZXNzaXZlOiBhZ2dyZXNzaXZlLFxyXG4gICAgZWFnZXI6IGVhZ2VyLFxyXG4gICAgcGFzc2l2ZTogcGFzc2l2ZSxcclxuICAgIGxhenk6IGxhenlcclxufTtcclxudmFyIHNldEludGVyYWN0aW9uTW9kZSA9IGZ1bmN0aW9uIChtb2RlLCBpbXBsZW1lbnRhdGlvbikge1xyXG4gICAgc2V0Q29uZmlnKHsgbW9kZTogbW9kZSB9KTtcclxuICAgIGlmICghaW1wbGVtZW50YXRpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoIWlzQ2FsbGFibGUoaW1wbGVtZW50YXRpb24pKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIG1vZGUgaW1wbGVtZW50YXRpb24gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XHJcbiAgICB9XHJcbiAgICBtb2Rlc1ttb2RlXSA9IGltcGxlbWVudGF0aW9uO1xyXG59O1xuXG52YXIgRVZFTlRfQlVTID0gbmV3IFZ1ZSgpO1xyXG5mdW5jdGlvbiBsb2NhbGVDaGFuZ2VkKCkge1xyXG4gICAgRVZFTlRfQlVTLiRlbWl0KCdjaGFuZ2U6bG9jYWxlJyk7XHJcbn1cblxudmFyIERpY3Rpb25hcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBEaWN0aW9uYXJ5KGxvY2FsZSwgZGljdGlvbmFyeSkge1xyXG4gICAgICAgIHRoaXMuY29udGFpbmVyID0ge307XHJcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBsb2NhbGU7XHJcbiAgICAgICAgdGhpcy5tZXJnZShkaWN0aW9uYXJ5KTtcclxuICAgIH1cclxuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbiAoZmllbGQsIHJ1bGUsIHZhbHVlcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCh0aGlzLmxvY2FsZSwgZmllbGQsIHJ1bGUsIHZhbHVlcyk7XHJcbiAgICB9O1xyXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKGxvY2FsZSwgZmllbGQsIHJ1bGUsIHZhbHVlcykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XHJcbiAgICAgICAgdmFyIG1lc3NhZ2U7XHJcbiAgICAgICAgLy8gZmluZCBpZiBzcGVjaWZpYyBtZXNzYWdlIGZvciB0aGF0IGZpZWxkIHdhcyBzcGVjaWZpZWQuXHJcbiAgICAgICAgbWVzc2FnZSA9ICgoX2MgPSAoX2IgPSAoX2EgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmllbGRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbZmllbGRdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbcnVsZV0pIHx8ICgoX2UgPSAoX2QgPSB0aGlzLmNvbnRhaW5lcltsb2NhbGVdKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWVzc2FnZXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZVtydWxlXSk7XHJcbiAgICAgICAgaWYgKCFtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UgPSAne2ZpZWxkfSBpcyBub3QgdmFsaWQnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZCA9IChfaCA9IChfZyA9IChfZiA9IHRoaXMuY29udGFpbmVyW2xvY2FsZV0pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5uYW1lcykgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nW2ZpZWxkXSwgKF9oICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IGZpZWxkKSk7XHJcbiAgICAgICAgcmV0dXJuIGlzQ2FsbGFibGUobWVzc2FnZSkgPyBtZXNzYWdlKGZpZWxkLCB2YWx1ZXMpIDogaW50ZXJwb2xhdGUobWVzc2FnZSwgX19hc3NpZ24oX19hc3NpZ24oe30sIHZhbHVlcyksIHsgX2ZpZWxkXzogZmllbGQgfSkpO1xyXG4gICAgfTtcclxuICAgIERpY3Rpb25hcnkucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKGRpY3Rpb25hcnkpIHtcclxuICAgICAgICBtZXJnZSh0aGlzLmNvbnRhaW5lciwgZGljdGlvbmFyeSk7XHJcbiAgICB9O1xyXG4gICAgRGljdGlvbmFyeS5wcm90b3R5cGUuaGFzUnVsZSA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gISEoKF9iID0gKF9hID0gdGhpcy5jb250YWluZXJbdGhpcy5sb2NhbGVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZXMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltuYW1lXSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIERpY3Rpb25hcnk7XHJcbn0oKSk7XHJcbnZhciBESUNUSU9OQVJZO1xyXG5mdW5jdGlvbiBsb2NhbGl6ZShsb2NhbGUsIGRpY3Rpb25hcnkpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICghRElDVElPTkFSWSkge1xyXG4gICAgICAgIERJQ1RJT05BUlkgPSBuZXcgRGljdGlvbmFyeSgnZW4nLCB7fSk7XHJcbiAgICAgICAgc2V0Q29uZmlnKHtcclxuICAgICAgICAgICAgZGVmYXVsdE1lc3NhZ2U6IGZ1bmN0aW9uIChmaWVsZCwgdmFsdWVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gRElDVElPTkFSWS5yZXNvbHZlKGZpZWxkLCAoX2EgPSB2YWx1ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fcnVsZV8sIHZhbHVlcyB8fCB7fSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbG9jYWxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIERJQ1RJT05BUlkubG9jYWxlID0gbG9jYWxlO1xyXG4gICAgICAgIGlmIChkaWN0aW9uYXJ5KSB7XHJcbiAgICAgICAgICAgIERJQ1RJT05BUlkubWVyZ2UoKF9hID0ge30sIF9hW2xvY2FsZV0gPSBkaWN0aW9uYXJ5LCBfYSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2NhbGVDaGFuZ2VkKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgRElDVElPTkFSWS5tZXJnZShsb2NhbGUpO1xyXG59XG5cbnZhciBpc0V2ZW50ID0gZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgaWYgKCFldnQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyAmJiBpc0NhbGxhYmxlKEV2ZW50KSAmJiBldnQgaW5zdGFuY2VvZiBFdmVudCkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gdGhpcyBpcyBmb3IgSUVcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAoZXZ0ICYmIGV2dC5zcmNFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn07XHJcbmZ1bmN0aW9uIG5vcm1hbGl6ZUV2ZW50VmFsdWUodmFsdWUpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICBpZiAoIWlzRXZlbnQodmFsdWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdmFyIGlucHV0ID0gdmFsdWUudGFyZ2V0O1xyXG4gICAgaWYgKGlucHV0LnR5cGUgPT09ICdmaWxlJyAmJiBpbnB1dC5maWxlcykge1xyXG4gICAgICAgIHJldHVybiB0b0FycmF5KGlucHV0LmZpbGVzKTtcclxuICAgIH1cclxuICAgIC8vIElmIHRoZSBpbnB1dCBoYXMgYSBgdi1tb2RlbC5udW1iZXJgIG1vZGlmaWVyIGFwcGxpZWQuXHJcbiAgICBpZiAoKF9hID0gaW5wdXQuX3ZNb2RpZmllcnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1iZXIpIHtcclxuICAgICAgICAvLyBhcyBwZXIgdGhlIHNwZWMgdGhlIHYtbW9kZWwubnVtYmVyIHVzZXMgcGFyc2VGbG9hdFxyXG4gICAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChpbnB1dC52YWx1ZSk7XHJcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlQXNOdW1iZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC52YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlQXNOdW1iZXI7XHJcbiAgICB9XHJcbiAgICBpZiAoKF9iID0gaW5wdXQuX3ZNb2RpZmllcnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50cmltKSB7XHJcbiAgICAgICAgdmFyIHRyaW1tZWRWYWx1ZSA9IHR5cGVvZiBpbnB1dC52YWx1ZSA9PT0gJ3N0cmluZycgPyBpbnB1dC52YWx1ZS50cmltKCkgOiBpbnB1dC52YWx1ZTtcclxuICAgICAgICByZXR1cm4gdHJpbW1lZFZhbHVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlucHV0LnZhbHVlO1xyXG59XG5cbnZhciBpc1RleHRJbnB1dCA9IGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgdmFyIF9hLCBfYjtcclxuICAgIHZhciBhdHRycyA9ICgoX2EgPSB2bm9kZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnMpIHx8IHZub2RlLmVsbTtcclxuICAgIC8vIGl0IHdpbGwgZmFsbGJhY2sgdG8gYmVpbmcgYSB0ZXh0IGlucHV0IHBlciBicm93c2VycyBzcGVjLlxyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ2lucHV0JyAmJiAoIWF0dHJzIHx8ICFhdHRycy50eXBlKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJykge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluY2x1ZGVzKFsndGV4dCcsICdwYXNzd29yZCcsICdzZWFyY2gnLCAnZW1haWwnLCAndGVsJywgJ3VybCcsICdudW1iZXInXSwgKF9iID0gYXR0cnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50eXBlKTtcclxufTtcclxuLy8gZXhwb3J0IGNvbnN0IGlzQ2hlY2tib3hPclJhZGlvSW5wdXQgPSAodm5vZGU6IFZOb2RlKTogYm9vbGVhbiA9PiB7XHJcbi8vICAgY29uc3QgYXR0cnMgPSAodm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLmF0dHJzKSB8fCB2bm9kZS5lbG07XHJcbi8vICAgcmV0dXJuIGluY2x1ZGVzKFsncmFkaW8nLCAnY2hlY2tib3gnXSwgYXR0cnMgJiYgYXR0cnMudHlwZSk7XHJcbi8vIH07XHJcbi8vIEdldHMgdGhlIG1vZGVsIG9iamVjdCBvbiB0aGUgdm5vZGUuXHJcbmZ1bmN0aW9uIGZpbmRNb2RlbCh2bm9kZSkge1xyXG4gICAgaWYgKCF2bm9kZS5kYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIC8vIENvbXBvbmVudCBNb2RlbFxyXG4gICAgLy8gVEhJUyBJUyBOT1QgVFlQRUQgSU4gT0ZGSUNJQUwgVlVFIFRZUElOR1NcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgdmFyIG5vblN0YW5kYXJkVk5vZGVEYXRhID0gdm5vZGUuZGF0YTtcclxuICAgIGlmICgnbW9kZWwnIGluIG5vblN0YW5kYXJkVk5vZGVEYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5vblN0YW5kYXJkVk5vZGVEYXRhLm1vZGVsO1xyXG4gICAgfVxyXG4gICAgaWYgKCF2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbmQodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC5uYW1lID09PSAnbW9kZWwnOyB9KTtcclxufVxyXG5mdW5jdGlvbiBmaW5kVmFsdWUodm5vZGUpIHtcclxuICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgdmFyIG1vZGVsID0gZmluZE1vZGVsKHZub2RlKTtcclxuICAgIGlmIChtb2RlbCkge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBtb2RlbC52YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbmZpZyA9IGZpbmRNb2RlbENvbmZpZyh2bm9kZSk7XHJcbiAgICB2YXIgcHJvcCA9ICgoX2EgPSBjb25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9wKSB8fCAndmFsdWUnO1xyXG4gICAgaWYgKCgoX2IgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHJvcHNEYXRhKSAmJiBwcm9wIGluIHZub2RlLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhKSB7XHJcbiAgICAgICAgdmFyIHByb3BzRGF0YVdpdGhWYWx1ZSA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhO1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBwcm9wc0RhdGFXaXRoVmFsdWVbcHJvcF0gfTtcclxuICAgIH1cclxuICAgIGlmICgoKF9jID0gdm5vZGUuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmRvbVByb3BzKSAmJiAndmFsdWUnIGluIHZub2RlLmRhdGEuZG9tUHJvcHMpIHtcclxuICAgICAgICByZXR1cm4geyB2YWx1ZTogdm5vZGUuZGF0YS5kb21Qcm9wcy52YWx1ZSB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0Q2hpbGRyZW4odm5vZGUpIHtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlKSkge1xyXG4gICAgICAgIHJldHVybiB2bm9kZTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KHZub2RlLmNoaWxkcmVuKSkge1xyXG4gICAgICAgIHJldHVybiB2bm9kZS5jaGlsZHJlbjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodm5vZGUuY29tcG9uZW50T3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHZub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgcmV0dXJuIHZub2RlLmNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW47XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuZnVuY3Rpb24gZXh0cmFjdFZOb2Rlcyh2bm9kZSkge1xyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZub2RlKSAmJiBmaW5kVmFsdWUodm5vZGUpICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gW3Zub2RlXTtcclxuICAgIH1cclxuICAgIHZhciBjaGlsZHJlbiA9IGV4dHJhY3RDaGlsZHJlbih2bm9kZSk7XHJcbiAgICByZXR1cm4gY2hpbGRyZW4ucmVkdWNlKGZ1bmN0aW9uIChub2Rlcywgbm9kZSkge1xyXG4gICAgICAgIHZhciBjYW5kaWRhdGVzID0gZXh0cmFjdFZOb2Rlcyhub2RlKTtcclxuICAgICAgICBpZiAoY2FuZGlkYXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbm9kZXMucHVzaC5hcHBseShub2RlcywgY2FuZGlkYXRlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlcztcclxuICAgIH0sIFtdKTtcclxufVxyXG4vLyBSZXNvbHZlcyB2LW1vZGVsIGNvbmZpZyBpZiBleGlzdHMuXHJcbmZ1bmN0aW9uIGZpbmRNb2RlbENvbmZpZyh2bm9kZSkge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghdm5vZGUuY29tcG9uZW50T3B0aW9ucylcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIC8vIFRoaXMgaXMgYWxzbyBub3QgdHlwZWQgaW4gdGhlIHN0YW5kYXJkIFZ1ZSBUUy5cclxuICAgIHJldHVybiB2bm9kZS5jb21wb25lbnRPcHRpb25zLkN0b3Iub3B0aW9ucy5tb2RlbDtcclxufVxyXG4vLyBBZGRzIGEgbGlzdGVuZXIgdG8gdm5vZGUgbGlzdGVuZXIgb2JqZWN0LlxyXG5mdW5jdGlvbiBtZXJnZVZOb2RlTGlzdGVuZXJzKG9iaiwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAvLyBubyBsaXN0ZW5lciBhdCBhbGwuXHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQob2JqW2V2ZW50TmFtZV0pKSB7XHJcbiAgICAgICAgb2JqW2V2ZW50TmFtZV0gPSBbaGFuZGxlcl07XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLy8gSXMgYW4gaW52b2tlci5cclxuICAgIGlmIChpc0NhbGxhYmxlKG9ialtldmVudE5hbWVdKSAmJiBvYmpbZXZlbnROYW1lXS5mbnMpIHtcclxuICAgICAgICB2YXIgaW52b2tlciA9IG9ialtldmVudE5hbWVdO1xyXG4gICAgICAgIGludm9rZXIuZm5zID0gQXJyYXkuaXNBcnJheShpbnZva2VyLmZucykgPyBpbnZva2VyLmZucyA6IFtpbnZva2VyLmZuc107XHJcbiAgICAgICAgaWYgKCFpbmNsdWRlcyhpbnZva2VyLmZucywgaGFuZGxlcikpIHtcclxuICAgICAgICAgICAgaW52b2tlci5mbnMucHVzaChoYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzQ2FsbGFibGUob2JqW2V2ZW50TmFtZV0pKSB7XHJcbiAgICAgICAgdmFyIHByZXYgPSBvYmpbZXZlbnROYW1lXTtcclxuICAgICAgICBvYmpbZXZlbnROYW1lXSA9IFtwcmV2XTtcclxuICAgIH1cclxuICAgIGlmIChBcnJheS5pc0FycmF5KG9ialtldmVudE5hbWVdKSAmJiAhaW5jbHVkZXMob2JqW2V2ZW50TmFtZV0sIGhhbmRsZXIpKSB7XHJcbiAgICAgICAgb2JqW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG4vLyBBZGRzIGEgbGlzdGVuZXIgdG8gYSBuYXRpdmUgSFRNTCB2bm9kZS5cclxuZnVuY3Rpb24gYWRkTmF0aXZlTm9kZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghbm9kZS5kYXRhKSB7XHJcbiAgICAgICAgbm9kZS5kYXRhID0ge307XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQobm9kZS5kYXRhLm9uKSkge1xyXG4gICAgICAgIG5vZGUuZGF0YS5vbiA9IHt9O1xyXG4gICAgfVxyXG4gICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhub2RlLmRhdGEub24sIGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbn1cclxuLy8gQWRkcyBhIGxpc3RlbmVyIHRvIGEgVnVlIGNvbXBvbmVudCB2bm9kZS5cclxuZnVuY3Rpb24gYWRkQ29tcG9uZW50Tm9kZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghbm9kZS5jb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICghbm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycykge1xyXG4gICAgICAgIG5vZGUuY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMgPSB7fTtcclxuICAgIH1cclxuICAgIG1lcmdlVk5vZGVMaXN0ZW5lcnMobm9kZS5jb21wb25lbnRPcHRpb25zLmxpc3RlbmVycywgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxufVxyXG5mdW5jdGlvbiBhZGRWTm9kZUxpc3RlbmVyKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgICAgYWRkQ29tcG9uZW50Tm9kZUxpc3RlbmVyKHZub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGFkZE5hdGl2ZU5vZGVMaXN0ZW5lcih2bm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcclxufVxyXG4vLyBEZXRlcm1pbmVzIGlmIGBjaGFuZ2VgIHNob3VsZCBiZSB1c2VkIG92ZXIgYGlucHV0YCBmb3IgbGlzdGVuZXJzLlxyXG5mdW5jdGlvbiBnZXRJbnB1dEV2ZW50TmFtZSh2bm9kZSwgbW9kZWwpIHtcclxuICAgIHZhciBfYSwgX2I7XHJcbiAgICAvLyBJcyBhIGNvbXBvbmVudC5cclxuICAgIGlmICh2bm9kZS5jb21wb25lbnRPcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIGV2ZW50XzEgPSAoZmluZE1vZGVsQ29uZmlnKHZub2RlKSB8fCB7IGV2ZW50OiAnaW5wdXQnIH0pLmV2ZW50O1xyXG4gICAgICAgIHJldHVybiBldmVudF8xO1xyXG4gICAgfVxyXG4gICAgLy8gTGF6eSBNb2RlbHMgdHlwaWNhbGx5IHVzZSBjaGFuZ2UgZXZlbnRcclxuICAgIGlmICgoX2IgPSAoX2EgPSBtb2RlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1vZGlmaWVycykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhenkpIHtcclxuICAgICAgICByZXR1cm4gJ2NoYW5nZSc7XHJcbiAgICB9XHJcbiAgICAvLyBpcyBhIHRleHR1YWwtdHlwZSBpbnB1dC5cclxuICAgIGlmIChpc1RleHRJbnB1dCh2bm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gJ2lucHV0JztcclxuICAgIH1cclxuICAgIHJldHVybiAnY2hhbmdlJztcclxufVxyXG5mdW5jdGlvbiBpc0hUTUxOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBpbmNsdWRlcyhbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYSddLCBub2RlLnRhZyk7XHJcbn1cclxuLy8gVE9ETzogVHlwZSB0aGlzIG9uZSBwcm9wZXJseS5cclxuZnVuY3Rpb24gbm9ybWFsaXplU2xvdHMoc2xvdHMsIGN0eCkge1xyXG4gICAgdmFyIGFjYyA9IFtdO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNsb3RzKS5yZWR1Y2UoZnVuY3Rpb24gKGFyciwga2V5KSB7XHJcbiAgICAgICAgc2xvdHNba2V5XS5mb3JFYWNoKGZ1bmN0aW9uICh2bm9kZSkge1xyXG4gICAgICAgICAgICBpZiAoIXZub2RlLmNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHNsb3RzW2tleV0uY29udGV4dCA9IGN0eDtcclxuICAgICAgICAgICAgICAgIGlmICghdm5vZGUuZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmRhdGEgPSB7fTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHZub2RlLmRhdGEuc2xvdCA9IGtleTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBhcnIuY29uY2F0KHNsb3RzW2tleV0pO1xyXG4gICAgfSwgYWNjKTtcclxufVxyXG5mdW5jdGlvbiByZXNvbHZlVGV4dHVhbFJ1bGVzKHZub2RlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgYXR0cnMgPSAoX2EgPSB2bm9kZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXR0cnM7XHJcbiAgICB2YXIgcnVsZXMgPSB7fTtcclxuICAgIGlmICghYXR0cnMpXHJcbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xyXG4gICAgaWYgKGF0dHJzLnR5cGUgPT09ICdlbWFpbCcgJiYgUnVsZUNvbnRhaW5lci5nZXRSdWxlRGVmaW5pdGlvbignZW1haWwnKSkge1xyXG4gICAgICAgIHJ1bGVzLmVtYWlsID0gWydtdWx0aXBsZScgaW4gYXR0cnNdO1xyXG4gICAgfVxyXG4gICAgaWYgKGF0dHJzLnBhdHRlcm4gJiYgUnVsZUNvbnRhaW5lci5nZXRSdWxlRGVmaW5pdGlvbigncmVnZXgnKSkge1xyXG4gICAgICAgIHJ1bGVzLnJlZ2V4ID0gYXR0cnMucGF0dGVybjtcclxuICAgIH1cclxuICAgIGlmIChhdHRycy5tYXhsZW5ndGggPj0gMCAmJiBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKCdtYXgnKSkge1xyXG4gICAgICAgIHJ1bGVzLm1heCA9IGF0dHJzLm1heGxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChhdHRycy5taW5sZW5ndGggPj0gMCAmJiBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKCdtaW4nKSkge1xyXG4gICAgICAgIHJ1bGVzLm1pbiA9IGF0dHJzLm1pbmxlbmd0aDtcclxuICAgIH1cclxuICAgIGlmIChhdHRycy50eXBlID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGlmIChpc1NwZWNpZmllZChhdHRycy5taW4pICYmIFJ1bGVDb250YWluZXIuZ2V0UnVsZURlZmluaXRpb24oJ21pbl92YWx1ZScpKSB7XHJcbiAgICAgICAgICAgIHJ1bGVzLm1pbl92YWx1ZSA9IE51bWJlcihhdHRycy5taW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNTcGVjaWZpZWQoYXR0cnMubWF4KSAmJiBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKCdtYXhfdmFsdWUnKSkge1xyXG4gICAgICAgICAgICBydWxlcy5tYXhfdmFsdWUgPSBOdW1iZXIoYXR0cnMubWF4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcnVsZXM7XHJcbn1cclxuZnVuY3Rpb24gcmVzb2x2ZVJ1bGVzKHZub2RlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgaHRtbFRhZ3MgPSBbJ2lucHV0JywgJ3NlbGVjdCcsICd0ZXh0YXJlYSddO1xyXG4gICAgdmFyIGF0dHJzID0gKF9hID0gdm5vZGUuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xyXG4gICAgaWYgKCFpbmNsdWRlcyhodG1sVGFncywgdm5vZGUudGFnKSB8fCAhYXR0cnMpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICB9XHJcbiAgICB2YXIgcnVsZXMgPSB7fTtcclxuICAgIGlmICgncmVxdWlyZWQnIGluIGF0dHJzICYmIGF0dHJzLnJlcXVpcmVkICE9PSBmYWxzZSAmJiBSdWxlQ29udGFpbmVyLmdldFJ1bGVEZWZpbml0aW9uKCdyZXF1aXJlZCcpKSB7XHJcbiAgICAgICAgcnVsZXMucmVxdWlyZWQgPSBhdHRycy50eXBlID09PSAnY2hlY2tib3gnID8gW3RydWVdIDogdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChpc1RleHRJbnB1dCh2bm9kZSkpIHtcclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplUnVsZXMoX19hc3NpZ24oX19hc3NpZ24oe30sIHJ1bGVzKSwgcmVzb2x2ZVRleHR1YWxSdWxlcyh2bm9kZSkpKTtcclxuICAgIH1cclxuICAgIHJldHVybiBub3JtYWxpemVSdWxlcyhydWxlcyk7XHJcbn1cclxuZnVuY3Rpb24gbm9ybWFsaXplQ2hpbGRyZW4oY29udGV4dCwgc2xvdFByb3BzKSB7XHJcbiAgICBpZiAoY29udGV4dC4kc2NvcGVkU2xvdHMuZGVmYXVsdCkge1xyXG4gICAgICAgIHJldHVybiBjb250ZXh0LiRzY29wZWRTbG90cy5kZWZhdWx0KHNsb3RQcm9wcykgfHwgW107XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY29udGV4dC4kc2xvdHMuZGVmYXVsdCB8fCBbXTtcclxufVxuXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIHByb3ZpZGVyIG5lZWRzIHRvIHJ1biB2YWxpZGF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gc2hvdWxkVmFsaWRhdGUoY3R4LCB2YWx1ZSkge1xyXG4gICAgLy8gd2hlbiBhbiBpbW1lZGlhdGUvaW5pdGlhbCB2YWxpZGF0aW9uIGlzIG5lZWRlZCBhbmQgd2Fzbid0IGRvbmUgYmVmb3JlLlxyXG4gICAgaWYgKCFjdHguX2lnbm9yZUltbWVkaWF0ZSAmJiBjdHguaW1tZWRpYXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvLyB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIGZvciB3aGF0ZXZlciByZWFzb24uXHJcbiAgICBpZiAoY3R4LnZhbHVlICE9PSB2YWx1ZSAmJiBjdHgubm9ybWFsaXplZEV2ZW50cy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIHdoZW4gaXQgbmVlZHMgdmFsaWRhdGlvbiBkdWUgdG8gcHJvcHMvY3Jvc3MtZmllbGRzIGNoYW5nZXMuXHJcbiAgICBpZiAoY3R4Ll9uZWVkc1ZhbGlkYXRpb24pIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIHdoZW4gdGhlIGluaXRpYWwgdmFsdWUgaXMgdW5kZWZpbmVkIGFuZCB0aGUgZmllbGQgd2Fzbid0IHJlbmRlcmVkIHlldC5cclxuICAgIGlmICghY3R4LmluaXRpYWxpemVkICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0aW9uQ3R4KGN0eCkge1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjdHguZmxhZ3MpLCB7IGVycm9yczogY3R4LmVycm9ycywgY2xhc3NlczogY3R4LmNsYXNzZXMsIGZhaWxlZFJ1bGVzOiBjdHguZmFpbGVkUnVsZXMsIHJlc2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjdHgucmVzZXQoKTsgfSwgdmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3R4LnZhbGlkYXRlLmFwcGx5KGN0eCwgYXJncyk7XHJcbiAgICAgICAgfSwgYXJpYUlucHV0OiB7XHJcbiAgICAgICAgICAgICdhcmlhLWludmFsaWQnOiBjdHguZmxhZ3MuaW52YWxpZCA/ICd0cnVlJyA6ICdmYWxzZScsXHJcbiAgICAgICAgICAgICdhcmlhLXJlcXVpcmVkJzogY3R4LmlzUmVxdWlyZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxyXG4gICAgICAgICAgICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiBcInZlZV9cIiArIGN0eC5pZFxyXG4gICAgICAgIH0sIGFyaWFNc2c6IHtcclxuICAgICAgICAgICAgaWQ6IFwidmVlX1wiICsgY3R4LmlkLFxyXG4gICAgICAgICAgICAnYXJpYS1saXZlJzogY3R4LmVycm9ycy5sZW5ndGggPyAnYXNzZXJ0aXZlJyA6ICdvZmYnXHJcbiAgICAgICAgfSB9KTtcclxufVxyXG5mdW5jdGlvbiBvblJlbmRlclVwZGF0ZSh2bSwgdmFsdWUpIHtcclxuICAgIGlmICghdm0uaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICB2bS5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHZhciB2YWxpZGF0ZU5vdyA9IHNob3VsZFZhbGlkYXRlKHZtLCB2YWx1ZSk7XHJcbiAgICB2bS5fbmVlZHNWYWxpZGF0aW9uID0gZmFsc2U7XHJcbiAgICB2bS52YWx1ZSA9IHZhbHVlO1xyXG4gICAgdm0uX2lnbm9yZUltbWVkaWF0ZSA9IHRydWU7XHJcbiAgICBpZiAoIXZhbGlkYXRlTm93KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh2bS5pbW1lZGlhdGUgfHwgdm0uZmxhZ3MudmFsaWRhdGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmlnZ2VyVGhyZWFkU2FmZVZhbGlkYXRpb24odm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2bS52YWxpZGF0ZVNpbGVudCgpO1xyXG4gICAgfTtcclxuICAgIGlmICh2bS5pbml0aWFsaXplZCkge1xyXG4gICAgICAgIHZhbGlkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdm0uJG9uY2UoJ2hvb2s6bW91bnRlZCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHZhbGlkYXRlKCk7IH0pO1xyXG59XHJcbmZ1bmN0aW9uIGNvbXB1dGVNb2RlU2V0dGluZyhjdHgpIHtcclxuICAgIHZhciBjb21wdXRlID0gKGlzQ2FsbGFibGUoY3R4Lm1vZGUpID8gY3R4Lm1vZGUgOiBtb2Rlc1tjdHgubW9kZV0pO1xyXG4gICAgcmV0dXJuIGNvbXB1dGUoY3R4KTtcclxufVxyXG5mdW5jdGlvbiB0cmlnZ2VyVGhyZWFkU2FmZVZhbGlkYXRpb24odm0pIHtcclxuICAgIHZhciBwZW5kaW5nUHJvbWlzZSA9IHZtLnZhbGlkYXRlU2lsZW50KCk7XHJcbiAgICAvLyBhdm9pZHMgcmFjZSBjb25kaXRpb25zIGJldHdlZW4gc3VjY2Vzc2l2ZSB2YWxpZGF0aW9ucy5cclxuICAgIHZtLl9wZW5kaW5nVmFsaWRhdGlvbiA9IHBlbmRpbmdQcm9taXNlO1xyXG4gICAgcmV0dXJuIHBlbmRpbmdQcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xyXG4gICAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSA9PT0gdm0uX3BlbmRpbmdWYWxpZGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHZtLmFwcGx5UmVzdWx0KHJlc3VsdCk7XHJcbiAgICAgICAgICAgIHZtLl9wZW5kaW5nVmFsaWRhdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH0pO1xyXG59XHJcbi8vIENyZWF0ZXMgdGhlIGNvbW1vbiBoYW5kbGVycyBmb3IgYSB2YWxpZGF0YWJsZSBjb250ZXh0LlxyXG5mdW5jdGlvbiBjcmVhdGVDb21tb25IYW5kbGVycyh2bSkge1xyXG4gICAgaWYgKCF2bS4kdmVlT25JbnB1dCkge1xyXG4gICAgICAgIHZtLiR2ZWVPbklucHV0ID0gZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgdm0uc3luY1ZhbHVlKGUpOyAvLyB0cmFjayBhbmQga2VlcCB0aGUgdmFsdWUgdXBkYXRlZC5cclxuICAgICAgICAgICAgdm0uc2V0RmxhZ3MoeyBkaXJ0eTogdHJ1ZSwgcHJpc3RpbmU6IGZhbHNlIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICB2YXIgb25JbnB1dCA9IHZtLiR2ZWVPbklucHV0O1xyXG4gICAgaWYgKCF2bS4kdmVlT25CbHVyKSB7XHJcbiAgICAgICAgdm0uJHZlZU9uQmx1ciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdm0uc2V0RmxhZ3MoeyB0b3VjaGVkOiB0cnVlLCB1bnRvdWNoZWQ6IGZhbHNlIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvLyBCbHVyIGV2ZW50IGxpc3RlbmVyLlxyXG4gICAgdmFyIG9uQmx1ciA9IHZtLiR2ZWVPbkJsdXI7XHJcbiAgICB2YXIgb25WYWxpZGF0ZSA9IHZtLiR2ZWVIYW5kbGVyO1xyXG4gICAgdmFyIG1vZGUgPSBjb21wdXRlTW9kZVNldHRpbmcodm0pO1xyXG4gICAgLy8gSGFuZGxlIGRlYm91bmNlIGNoYW5nZXMuXHJcbiAgICBpZiAoIW9uVmFsaWRhdGUgfHwgdm0uJHZlZURlYm91bmNlICE9PSB2bS5kZWJvdW5jZSkge1xyXG4gICAgICAgIG9uVmFsaWRhdGUgPSBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZtLiRuZXh0VGljayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXZtLl9wZW5kaW5nUmVzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyVGhyZWFkU2FmZVZhbGlkYXRpb24odm0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdm0uX3BlbmRpbmdSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LCBtb2RlLmRlYm91bmNlIHx8IHZtLmRlYm91bmNlKTtcclxuICAgICAgICAvLyBDYWNoZSB0aGUgaGFuZGxlciBzbyB3ZSBkb24ndCBjcmVhdGUgaXQgZWFjaCB0aW1lLlxyXG4gICAgICAgIHZtLiR2ZWVIYW5kbGVyID0gb25WYWxpZGF0ZTtcclxuICAgICAgICAvLyBjYWNoZSB0aGUgZGVib3VuY2UgdmFsdWUgc28gd2UgZGV0ZWN0IGlmIGl0IHdhcyBjaGFuZ2VkLlxyXG4gICAgICAgIHZtLiR2ZWVEZWJvdW5jZSA9IHZtLmRlYm91bmNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgb25JbnB1dDogb25JbnB1dCwgb25CbHVyOiBvbkJsdXIsIG9uVmFsaWRhdGU6IG9uVmFsaWRhdGUgfTtcclxufVxyXG4vLyBBZGRzIGFsbCBwbHVnaW4gbGlzdGVuZXJzIHRvIHRoZSB2bm9kZS5cclxuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHZtLCBub2RlKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICB2YXIgdmFsdWUgPSBmaW5kVmFsdWUobm9kZSk7XHJcbiAgICAvLyBjYWNoZSB0aGUgaW5wdXQgZXZlbnROYW1lLlxyXG4gICAgdm0uX2lucHV0RXZlbnROYW1lID0gdm0uX2lucHV0RXZlbnROYW1lIHx8IGdldElucHV0RXZlbnROYW1lKG5vZGUsIGZpbmRNb2RlbChub2RlKSk7XHJcbiAgICBvblJlbmRlclVwZGF0ZSh2bSwgKF9hID0gdmFsdWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS52YWx1ZSk7XHJcbiAgICB2YXIgX2IgPSBjcmVhdGVDb21tb25IYW5kbGVycyh2bSksIG9uSW5wdXQgPSBfYi5vbklucHV0LCBvbkJsdXIgPSBfYi5vbkJsdXIsIG9uVmFsaWRhdGUgPSBfYi5vblZhbGlkYXRlO1xyXG4gICAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCB2bS5faW5wdXRFdmVudE5hbWUsIG9uSW5wdXQpO1xyXG4gICAgYWRkVk5vZGVMaXN0ZW5lcihub2RlLCAnYmx1cicsIG9uQmx1cik7XHJcbiAgICAvLyBhZGQgdGhlIHZhbGlkYXRpb24gbGlzdGVuZXJzLlxyXG4gICAgdm0ubm9ybWFsaXplZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICBhZGRWTm9kZUxpc3RlbmVyKG5vZGUsIGV2dCwgb25WYWxpZGF0ZSk7XHJcbiAgICB9KTtcclxuICAgIHZtLmluaXRpYWxpemVkID0gdHJ1ZTtcclxufVxuXG52YXIgUFJPVklERVJfQ09VTlRFUiA9IDA7XHJcbmZ1bmN0aW9uIGRhdGEoKSB7XHJcbiAgICB2YXIgZXJyb3JzID0gW107XHJcbiAgICB2YXIgZmllbGROYW1lID0gJyc7XHJcbiAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IHtcclxuICAgICAgICBlcnJvcnM6IGVycm9ycyxcclxuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxyXG4gICAgICAgIGluaXRpYWxpemVkOiBmYWxzZSxcclxuICAgICAgICBpbml0aWFsVmFsdWU6IHVuZGVmaW5lZCxcclxuICAgICAgICBmbGFnczogY3JlYXRlRmxhZ3MoKSxcclxuICAgICAgICBmYWlsZWRSdWxlczoge30sXHJcbiAgICAgICAgaXNBY3RpdmU6IHRydWUsXHJcbiAgICAgICAgZmllbGROYW1lOiBmaWVsZE5hbWUsXHJcbiAgICAgICAgaWQ6ICcnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZXM7XHJcbn1cclxudmFyIFZhbGlkYXRpb25Qcm92aWRlciA9IFZ1ZS5leHRlbmQoe1xyXG4gICAgaW5qZWN0OiB7XHJcbiAgICAgICAgJF92ZWVPYnNlcnZlcjoge1xyXG4gICAgICAgICAgICBmcm9tOiAnJF92ZWVPYnNlcnZlcicsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyID0gY3JlYXRlT2JzZXJ2ZXIoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLiR2bm9kZS5jb250ZXh0LiRfdmVlT2JzZXJ2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICB2aWQ6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiAnJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbmFtZToge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IG51bGxcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1vZGU6IHtcclxuICAgICAgICAgICAgdHlwZTogW1N0cmluZywgRnVuY3Rpb25dLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29uZmlnKCkubW9kZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcnVsZXM6IHtcclxuICAgICAgICAgICAgdHlwZTogW09iamVjdCwgU3RyaW5nXSxcclxuICAgICAgICAgICAgZGVmYXVsdDogbnVsbFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaW1tZWRpYXRlOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgfSxcclxuICAgICAgICBiYWlsczoge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBnZXRDb25maWcoKS5iYWlsczsgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2tpcElmRW1wdHk6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0Q29uZmlnKCkuc2tpcE9wdGlvbmFsOyB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZWJvdW5jZToge1xyXG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IDBcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRhZzoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdzcGFuJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2xpbToge1xyXG4gICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIGN1c3RvbU1lc3NhZ2VzOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCxcclxuICAgICAgICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHdhdGNoOiB7XHJcbiAgICAgICAgcnVsZXM6IHtcclxuICAgICAgICAgICAgZGVlcDogdHJ1ZSxcclxuICAgICAgICAgICAgaGFuZGxlcjogZnVuY3Rpb24gKHZhbCwgb2xkVmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc1ZhbGlkYXRpb24gPSAhaXNFcXVhbCh2YWwsIG9sZFZhbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgZGF0YTogZGF0YSxcclxuICAgIGNvbXB1dGVkOiB7XHJcbiAgICAgICAgZmllbGREZXBzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLm5vcm1hbGl6ZWRSdWxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJ1bGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBkZXBzID0gZXh0cmFjdExvY2F0b3JzKF90aGlzLm5vcm1hbGl6ZWRSdWxlc1tydWxlXSkubWFwKGZ1bmN0aW9uIChkZXApIHsgcmV0dXJuIGRlcC5fX2xvY2F0b3JSZWY7IH0pO1xyXG4gICAgICAgICAgICAgICAgYWNjLnB1c2guYXBwbHkoYWNjLCBkZXBzKTtcclxuICAgICAgICAgICAgICAgIGRlcHMuZm9yRWFjaChmdW5jdGlvbiAoZGVwTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoQ3Jvc3NGaWVsZERlcChfdGhpcywgZGVwTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgICAgIH0sIFtdKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIG5vcm1hbGl6ZWRFdmVudHM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgdmFyIG9uID0gY29tcHV0ZU1vZGVTZXR0aW5nKHRoaXMpLm9uO1xyXG4gICAgICAgICAgICByZXR1cm4gKG9uIHx8IFtdKS5tYXAoZnVuY3Rpb24gKGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlID09PSAnaW5wdXQnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9pbnB1dEV2ZW50TmFtZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGlzUmVxdWlyZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3Jlc29sdmVkUnVsZXMpLCB0aGlzLm5vcm1hbGl6ZWRSdWxlcyk7XHJcbiAgICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gT2JqZWN0LmtleXMocnVsZXMpLnNvbWUoUnVsZUNvbnRhaW5lci5pc1JlcXVpcmVSdWxlKTtcclxuICAgICAgICAgICAgdGhpcy5mbGFncy5yZXF1aXJlZCA9ICEhaXNSZXF1aXJlZDtcclxuICAgICAgICAgICAgcmV0dXJuIGlzUmVxdWlyZWQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGFzc2VzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBuYW1lcyA9IGdldENvbmZpZygpLmNsYXNzZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wdXRlQ2xhc3NPYmoobmFtZXMsIHRoaXMuZmxhZ3MpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbm9ybWFsaXplZFJ1bGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVSdWxlcyh0aGlzLnJ1bGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIG9uTG9jYWxlQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCFfdGhpcy5mbGFncy52YWxpZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgcmVnZW5lcmF0ZU1hcCA9IF90aGlzLl9yZWdlbmVyYXRlTWFwO1xyXG4gICAgICAgICAgICBpZiAocmVnZW5lcmF0ZU1hcCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yc18xID0gW107XHJcbiAgICAgICAgICAgICAgICB2YXIgZmFpbGVkUnVsZXNfMSA9IHt9O1xyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocmVnZW5lcmF0ZU1hcCkuZm9yRWFjaChmdW5jdGlvbiAocnVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtc2cgPSByZWdlbmVyYXRlTWFwW3J1bGVdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzXzEucHVzaChtc2cpO1xyXG4gICAgICAgICAgICAgICAgICAgIGZhaWxlZFJ1bGVzXzFbcnVsZV0gPSBtc2c7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFwcGx5UmVzdWx0KHsgZXJyb3JzOiBlcnJvcnNfMSwgZmFpbGVkUnVsZXM6IGZhaWxlZFJ1bGVzXzEsIHJlZ2VuZXJhdGVNYXA6IHJlZ2VuZXJhdGVNYXAgfSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgX3RoaXMudmFsaWRhdGUoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIEVWRU5UX0JVUy4kb24oJ2NoYW5nZTpsb2NhbGUnLCBvbkxvY2FsZUNoYW5nZWQpO1xyXG4gICAgICAgIHRoaXMuJG9uKCdob29rOmJlZm9yZURlc3Ryb3knLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIEVWRU5UX0JVUy4kb2ZmKCdjaGFuZ2U6bG9jYWxlJywgb25Mb2NhbGVDaGFuZ2VkKTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcbiAgICByZW5kZXI6IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLnJlZ2lzdGVyRmllbGQoKTtcclxuICAgICAgICB2YXIgY3R4ID0gY3JlYXRlVmFsaWRhdGlvbkN0eCh0aGlzKTtcclxuICAgICAgICB2YXIgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbih0aGlzLCBjdHgpO1xyXG4gICAgICAgIC8vIEhhbmRsZSBzaW5nbGUtcm9vdCBzbG90LlxyXG4gICAgICAgIGV4dHJhY3RWTm9kZXMoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICAgICAgLy8gcmVzb2x2ZWQgcnVsZXMgYXJlIG5vdCByZWFjdGl2ZSBiZWNhdXNlIGl0IGhhcyBhIG5ldyByZWZlcmVuY2UgZWFjaCB0aW1lLlxyXG4gICAgICAgICAgICAvLyBjYXVzaW5nIGluZmluaXRlIHJlbmRlci1sb29wcy5cclxuICAgICAgICAgICAgLy8gU28gd2UgYXJlIGNvbXBhcmluZyB0aGVtIG1hbnVhbGx5IHRvIGRlY2lkZSBpZiB3ZSBuZWVkIHRvIHZhbGlkYXRlIG9yIG5vdC5cclxuICAgICAgICAgICAgdmFyIHJlc29sdmVkID0gZ2V0Q29uZmlnKCkudXNlQ29uc3RyYWludEF0dHJzID8gcmVzb2x2ZVJ1bGVzKGlucHV0KSA6IHt9O1xyXG4gICAgICAgICAgICBpZiAoIWlzRXF1YWwoX3RoaXMuX3Jlc29sdmVkUnVsZXMsIHJlc29sdmVkKSkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX25lZWRzVmFsaWRhdGlvbiA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzSFRNTE5vZGUoaW5wdXQpKSB7XHJcbiAgICAgICAgICAgICAgICBfdGhpcy5maWVsZE5hbWUgPSAoKF9iID0gKF9hID0gaW5wdXQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSkgfHwgKChfZCA9IChfYyA9IGlucHV0LmRhdGEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5hdHRycykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmlkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBfdGhpcy5fcmVzb2x2ZWRSdWxlcyA9IHJlc29sdmVkO1xyXG4gICAgICAgICAgICBhZGRMaXN0ZW5lcnMoX3RoaXMsIGlucHV0KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zbGltICYmIGNoaWxkcmVuLmxlbmd0aCA8PSAxID8gY2hpbGRyZW5bMF0gOiBoKHRoaXMudGFnLCBjaGlsZHJlbik7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIGNsZWFudXAgcmVmZXJlbmNlLlxyXG4gICAgICAgIHRoaXMuJF92ZWVPYnNlcnZlci51bm9ic2VydmUodGhpcy5pZCk7XHJcbiAgICB9LFxyXG4gICAgYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIHNldEZsYWdzOiBmdW5jdGlvbiAoZmxhZ3MpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmxhZ3MpLmZvckVhY2goZnVuY3Rpb24gKGZsYWcpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmZsYWdzW2ZsYWddID0gZmxhZ3NbZmxhZ107XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3luY1ZhbHVlOiBmdW5jdGlvbiAodikge1xyXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub3JtYWxpemVFdmVudFZhbHVlKHYpO1xyXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ3MuY2hhbmdlZCA9IHRoaXMuaW5pdGlhbFZhbHVlICE9PSB2YWx1ZTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuZXJyb3JzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gdGhpcy52YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGZsYWdzID0gY3JlYXRlRmxhZ3MoKTtcclxuICAgICAgICAgICAgZmxhZ3MucmVxdWlyZWQgPSB0aGlzLmlzUmVxdWlyZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0RmxhZ3MoZmxhZ3MpO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFJ1bGVzID0ge307XHJcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVTaWxlbnQoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1ZhbGlkYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdSZXNldCA9IHRydWU7XHJcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdSZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICB9LCB0aGlzLmRlYm91bmNlKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zeW5jVmFsdWUoYXJnc1swXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cmlnZ2VyVGhyZWFkU2FmZVZhbGlkYXRpb24odGhpcyldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsaWRhdGVTaWxlbnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJ1bGVzLCByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZsYWdzKHsgcGVuZGluZzogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRoaXMuX3Jlc29sdmVkUnVsZXMpLCB0aGlzLm5vcm1hbGl6ZWRSdWxlcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocnVsZXMsICdfJCRpc05vcm1hbGl6ZWQnLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdmFsaWRhdGUodGhpcy52YWx1ZSwgcnVsZXMsIF9fYXNzaWduKF9fYXNzaWduKHsgbmFtZTogdGhpcy5uYW1lIHx8IHRoaXMuZmllbGROYW1lIH0sIGNyZWF0ZUxvb2t1cCh0aGlzKSksIHsgYmFpbHM6IHRoaXMuYmFpbHMsIHNraXBJZkVtcHR5OiB0aGlzLnNraXBJZkVtcHR5LCBpc0luaXRpYWw6ICF0aGlzLmluaXRpYWxpemVkLCBjdXN0b21NZXNzYWdlczogdGhpcy5jdXN0b21NZXNzYWdlcyB9KSldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEZsYWdzKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZDogcmVzdWx0LnZhbGlkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmFsaWQ6ICFyZXN1bHQudmFsaWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3VsdF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0RXJyb3JzOiBmdW5jdGlvbiAoZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlSZXN1bHQoeyBlcnJvcnM6IGVycm9ycywgZmFpbGVkUnVsZXM6IHt9IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXBwbHlSZXN1bHQ6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgZXJyb3JzID0gX2EuZXJyb3JzLCBmYWlsZWRSdWxlcyA9IF9hLmZhaWxlZFJ1bGVzLCByZWdlbmVyYXRlTWFwID0gX2EucmVnZW5lcmF0ZU1hcDtcclxuICAgICAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVNYXAgPSByZWdlbmVyYXRlTWFwO1xyXG4gICAgICAgICAgICB0aGlzLmZhaWxlZFJ1bGVzID0gX19hc3NpZ24oe30sIChmYWlsZWRSdWxlcyB8fCB7fSkpO1xyXG4gICAgICAgICAgICB0aGlzLnNldEZsYWdzKHtcclxuICAgICAgICAgICAgICAgIHZhbGlkOiAhZXJyb3JzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHBhc3NlZDogIWVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBpbnZhbGlkOiAhIWVycm9ycy5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICBmYWlsZWQ6ICEhZXJyb3JzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgIHZhbGlkYXRlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYW5nZWQ6IHRoaXMudmFsdWUgIT09IHRoaXMuaW5pdGlhbFZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcmVnaXN0ZXJGaWVsZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB1cGRhdGVSZW5kZXJpbmdDb250ZXh0UmVmcyh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pO1xyXG5mdW5jdGlvbiBjb21wdXRlQ2xhc3NPYmoobmFtZXMsIGZsYWdzKSB7XHJcbiAgICB2YXIgYWNjID0ge307XHJcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcclxuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICB2YXIgZmxhZyA9IGtleXNbaV07XHJcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IChuYW1lcyAmJiBuYW1lc1tmbGFnXSkgfHwgZmxhZztcclxuICAgICAgICB2YXIgdmFsdWUgPSBmbGFnc1tmbGFnXTtcclxuICAgICAgICBpZiAoaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoZmxhZyA9PT0gJ3ZhbGlkJyB8fCBmbGFnID09PSAnaW52YWxpZCcpICYmICFmbGFncy52YWxpZGF0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGFjY1tjbGFzc05hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2xhc3NOYW1lKSkge1xyXG4gICAgICAgICAgICBjbGFzc05hbWUuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7XHJcbiAgICAgICAgICAgICAgICBhY2NbY2xzXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIF9sb29wXzEoaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYWNjO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZUxvb2t1cCh2bSkge1xyXG4gICAgdmFyIHByb3ZpZGVycyA9IHZtLiRfdmVlT2JzZXJ2ZXIucmVmcztcclxuICAgIHZhciByZWR1Y2VkID0ge1xyXG4gICAgICAgIG5hbWVzOiB7fSxcclxuICAgICAgICB2YWx1ZXM6IHt9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIHZtLmZpZWxkRGVwcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgZGVwTmFtZSkge1xyXG4gICAgICAgIGlmICghcHJvdmlkZXJzW2RlcE5hbWVdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGFjYy52YWx1ZXNbZGVwTmFtZV0gPSBwcm92aWRlcnNbZGVwTmFtZV0udmFsdWU7XHJcbiAgICAgICAgYWNjLm5hbWVzW2RlcE5hbWVdID0gcHJvdmlkZXJzW2RlcE5hbWVdLm5hbWU7XHJcbiAgICAgICAgcmV0dXJuIGFjYztcclxuICAgIH0sIHJlZHVjZWQpO1xyXG59XHJcbmZ1bmN0aW9uIGV4dHJhY3RJZCh2bSkge1xyXG4gICAgaWYgKHZtLnZpZCkge1xyXG4gICAgICAgIHJldHVybiB2bS52aWQ7XHJcbiAgICB9XHJcbiAgICBpZiAodm0ubmFtZSkge1xyXG4gICAgICAgIHJldHVybiB2bS5uYW1lO1xyXG4gICAgfVxyXG4gICAgaWYgKHZtLmlkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZtLmlkO1xyXG4gICAgfVxyXG4gICAgaWYgKHZtLmZpZWxkTmFtZSkge1xyXG4gICAgICAgIHJldHVybiB2bS5maWVsZE5hbWU7XHJcbiAgICB9XHJcbiAgICBQUk9WSURFUl9DT1VOVEVSKys7XHJcbiAgICByZXR1cm4gXCJfdmVlX1wiICsgUFJPVklERVJfQ09VTlRFUjtcclxufVxyXG5mdW5jdGlvbiB1cGRhdGVSZW5kZXJpbmdDb250ZXh0UmVmcyh2bSkge1xyXG4gICAgdmFyIHByb3ZpZGVkSWQgPSBleHRyYWN0SWQodm0pO1xyXG4gICAgdmFyIGlkID0gdm0uaWQ7XHJcbiAgICAvLyBOb3RoaW5nIGhhcyBjaGFuZ2VkLlxyXG4gICAgaWYgKCF2bS5pc0FjdGl2ZSB8fCAoaWQgPT09IHByb3ZpZGVkSWQgJiYgdm0uJF92ZWVPYnNlcnZlci5yZWZzW2lkXSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICAvLyB2aWQgd2FzIGNoYW5nZWQuXHJcbiAgICBpZiAoaWQgIT09IHByb3ZpZGVkSWQgJiYgdm0uJF92ZWVPYnNlcnZlci5yZWZzW2lkXSA9PT0gdm0pIHtcclxuICAgICAgICB2bS4kX3ZlZU9ic2VydmVyLnVub2JzZXJ2ZShpZCk7XHJcbiAgICB9XHJcbiAgICB2bS5pZCA9IHByb3ZpZGVkSWQ7XHJcbiAgICB2bS4kX3ZlZU9ic2VydmVyLm9ic2VydmUodm0pO1xyXG59XHJcbmZ1bmN0aW9uIGNyZWF0ZU9ic2VydmVyKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWZzOiB7fSxcclxuICAgICAgICBvYnNlcnZlOiBmdW5jdGlvbiAodm0pIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZzW3ZtLmlkXSA9IHZtO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdW5vYnNlcnZlOiBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiB3YXRjaENyb3NzRmllbGREZXAoY3R4LCBkZXBOYW1lLCB3aXRoSG9va3MpIHtcclxuICAgIGlmICh3aXRoSG9va3MgPT09IHZvaWQgMCkgeyB3aXRoSG9va3MgPSB0cnVlOyB9XHJcbiAgICB2YXIgcHJvdmlkZXJzID0gY3R4LiRfdmVlT2JzZXJ2ZXIucmVmcztcclxuICAgIGlmICghY3R4Ll92ZWVXYXRjaGVycykge1xyXG4gICAgICAgIGN0eC5fdmVlV2F0Y2hlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIGlmICghcHJvdmlkZXJzW2RlcE5hbWVdICYmIHdpdGhIb29rcykge1xyXG4gICAgICAgIHJldHVybiBjdHguJG9uY2UoJ2hvb2s6bW91bnRlZCcsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgd2F0Y2hDcm9zc0ZpZWxkRGVwKGN0eCwgZGVwTmFtZSwgZmFsc2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgaWYgKCFpc0NhbGxhYmxlKGN0eC5fdmVlV2F0Y2hlcnNbZGVwTmFtZV0pICYmIHByb3ZpZGVyc1tkZXBOYW1lXSkge1xyXG4gICAgICAgIGN0eC5fdmVlV2F0Y2hlcnNbZGVwTmFtZV0gPSBwcm92aWRlcnNbZGVwTmFtZV0uJHdhdGNoKCd2YWx1ZScsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKGN0eC5mbGFncy52YWxpZGF0ZWQpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5fbmVlZHNWYWxpZGF0aW9uID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGN0eC52YWxpZGF0ZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cblxudmFyIEZMQUdTX1NUUkFURUdJRVMgPSBbXHJcbiAgICBbJ3ByaXN0aW5lJywgJ2V2ZXJ5J10sXHJcbiAgICBbJ2RpcnR5JywgJ3NvbWUnXSxcclxuICAgIFsndG91Y2hlZCcsICdzb21lJ10sXHJcbiAgICBbJ3VudG91Y2hlZCcsICdldmVyeSddLFxyXG4gICAgWyd2YWxpZCcsICdldmVyeSddLFxyXG4gICAgWydpbnZhbGlkJywgJ3NvbWUnXSxcclxuICAgIFsncGVuZGluZycsICdzb21lJ10sXHJcbiAgICBbJ3ZhbGlkYXRlZCcsICdldmVyeSddLFxyXG4gICAgWydjaGFuZ2VkJywgJ3NvbWUnXSxcclxuICAgIFsncGFzc2VkJywgJ2V2ZXJ5J10sXHJcbiAgICBbJ2ZhaWxlZCcsICdzb21lJ11cclxuXTtcclxudmFyIE9CU0VSVkVSX0NPVU5URVIgPSAwO1xyXG5mdW5jdGlvbiBkYXRhJDEoKSB7XHJcbiAgICB2YXIgcmVmcyA9IHt9O1xyXG4gICAgdmFyIGVycm9ycyA9IHt9O1xyXG4gICAgdmFyIGZsYWdzID0gY3JlYXRlT2JzZXJ2ZXJGbGFncygpO1xyXG4gICAgdmFyIGZpZWxkcyA9IHt9O1xyXG4gICAgLy8gRklYTUU6IE5vdCBzdXJlIG9mIHRoaXMgb25lIGNhbiBiZSB0eXBlZCwgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UuXHJcbiAgICB2YXIgb2JzZXJ2ZXJzID0gW107XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiAnJyxcclxuICAgICAgICByZWZzOiByZWZzLFxyXG4gICAgICAgIG9ic2VydmVyczogb2JzZXJ2ZXJzLFxyXG4gICAgICAgIGVycm9yczogZXJyb3JzLFxyXG4gICAgICAgIGZsYWdzOiBmbGFncyxcclxuICAgICAgICBmaWVsZHM6IGZpZWxkc1xyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBwcm92aWRlU2VsZigpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgJF92ZWVPYnNlcnZlcjogdGhpc1xyXG4gICAgfTtcclxufVxyXG52YXIgVmFsaWRhdGlvbk9ic2VydmVyID0gVnVlLmV4dGVuZCh7XHJcbiAgICBuYW1lOiAnVmFsaWRhdGlvbk9ic2VydmVyJyxcclxuICAgIHByb3ZpZGU6IHByb3ZpZGVTZWxmLFxyXG4gICAgaW5qZWN0OiB7XHJcbiAgICAgICAgJF92ZWVPYnNlcnZlcjoge1xyXG4gICAgICAgICAgICBmcm9tOiAnJF92ZWVPYnNlcnZlcicsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4kdm5vZGUuY29udGV4dC4kX3ZlZU9ic2VydmVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByb3BzOiB7XHJcbiAgICAgICAgdGFnOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcclxuICAgICAgICAgICAgZGVmYXVsdDogJ3NwYW4nXHJcbiAgICAgICAgfSxcclxuICAgICAgICB2aWQ6IHtcclxuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICAgICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJvYnNfXCIgKyBPQlNFUlZFUl9DT1VOVEVSKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNsaW06IHtcclxuICAgICAgICAgICAgdHlwZTogQm9vbGVhbixcclxuICAgICAgICAgICAgZGVmYXVsdDogZmFsc2VcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRpc2FibGVkOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIGRhdGE6IGRhdGEkMSxcclxuICAgIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLnZpZDtcclxuICAgICAgICByZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICB2YXIgb25DaGFuZ2UgPSBkZWJvdW5jZShmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgdmFyIGVycm9ycyA9IF9hLmVycm9ycywgZmxhZ3MgPSBfYS5mbGFncywgZmllbGRzID0gX2EuZmllbGRzO1xyXG4gICAgICAgICAgICBfdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICAgICAgICAgIF90aGlzLmZsYWdzID0gZmxhZ3M7XHJcbiAgICAgICAgICAgIF90aGlzLmZpZWxkcyA9IGZpZWxkcztcclxuICAgICAgICB9LCAxNik7XHJcbiAgICAgICAgdGhpcy4kd2F0Y2goY29tcHV0ZU9ic2VydmVyU3RhdGUsIG9uQ2hhbmdlKTtcclxuICAgIH0sXHJcbiAgICBhY3RpdmF0ZWQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZWdpc3Rlcih0aGlzKTtcclxuICAgIH0sXHJcbiAgICBkZWFjdGl2YXRlZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICB9LFxyXG4gICAgcmVuZGVyOiBmdW5jdGlvbiAoaCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IG5vcm1hbGl6ZUNoaWxkcmVuKHRoaXMsIHByZXBhcmVTbG90UHJvcHModGhpcykpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNsaW0gJiYgY2hpbGRyZW4ubGVuZ3RoIDw9IDEgPyBjaGlsZHJlblswXSA6IGgodGhpcy50YWcsIHsgb246IHRoaXMuJGxpc3RlbmVycyB9LCBjaGlsZHJlbik7XHJcbiAgICB9LFxyXG4gICAgbWV0aG9kczoge1xyXG4gICAgICAgIG9ic2VydmU6IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBraW5kKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IHZvaWQgMCkgeyBraW5kID0gJ3Byb3ZpZGVyJzsgfVxyXG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gJ29ic2VydmVyJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJlZnMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy5yZWZzKSwgKF9hID0ge30sIF9hW3N1YnNjcmliZXIuaWRdID0gc3Vic2NyaWJlciwgX2EpKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHVub2JzZXJ2ZTogZnVuY3Rpb24gKGlkLCBraW5kKSB7XHJcbiAgICAgICAgICAgIGlmIChraW5kID09PSB2b2lkIDApIHsga2luZCA9ICdwcm92aWRlcic7IH1cclxuICAgICAgICAgICAgaWYgKGtpbmQgPT09ICdwcm92aWRlcicpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHRoaXMucmVmc1tpZF07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMucmVmcywgaWQpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBpZHggPSBmaW5kSW5kZXgodGhpcy5vYnNlcnZlcnMsIGZ1bmN0aW9uIChvKSB7IHJldHVybiBvLmlkID09PSBpZDsgfSk7XHJcbiAgICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaWR4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdmFsaWRhdGU6IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICB2YXIgX2IgPSAoX2EgPT09IHZvaWQgMCA/IHt9IDogX2EpLnNpbGVudCwgc2lsZW50ID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBQcm9taXNlLmFsbChfX3NwcmVhZEFycmF5cyh2YWx1ZXModGhpcy5yZWZzKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHIpIHsgcmV0dXJuICFyLmRpc2FibGVkOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmW3NpbGVudCA/ICd2YWxpZGF0ZVNpbGVudCcgOiAndmFsaWRhdGUnXSgpLnRoZW4oZnVuY3Rpb24gKHIpIHsgcmV0dXJuIHIudmFsaWQ7IH0pOyB9KSwgdGhpcy5vYnNlcnZlcnMuZmlsdGVyKGZ1bmN0aW9uIChvKSB7IHJldHVybiAhby5kaXNhYmxlZDsgfSkubWFwKGZ1bmN0aW9uIChvYnMpIHsgcmV0dXJuIG9icy52YWxpZGF0ZSh7IHNpbGVudDogc2lsZW50IH0pOyB9KSkpXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IF9jLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXN1bHRzLmV2ZXJ5KGZ1bmN0aW9uIChyKSB7IHJldHVybiByOyB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGFuZGxlU3VibWl0OiBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzVmFsaWQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudmFsaWRhdGUoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQgfHwgIWNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNiKCldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5cyh2YWx1ZXModGhpcy5yZWZzKSwgdGhpcy5vYnNlcnZlcnMpLmZvckVhY2goZnVuY3Rpb24gKHJlZikgeyByZXR1cm4gcmVmLnJlc2V0KCk7IH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0RXJyb3JzOiBmdW5jdGlvbiAoZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBfdGhpcy5yZWZzW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIHZhciBlcnJvckFyciA9IGVycm9yc1trZXldIHx8IFtdO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JBcnIgPSB0eXBlb2YgZXJyb3JBcnIgPT09ICdzdHJpbmcnID8gW2Vycm9yQXJyXSA6IGVycm9yQXJyO1xyXG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuc2V0RXJyb3JzKGVycm9yQXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5zZXRFcnJvcnMoZXJyb3JzKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59KTtcclxuZnVuY3Rpb24gdW5yZWdpc3Rlcih2bSkge1xyXG4gICAgaWYgKHZtLiRfdmVlT2JzZXJ2ZXIpIHtcclxuICAgICAgICB2bS4kX3ZlZU9ic2VydmVyLnVub2JzZXJ2ZSh2bS5pZCwgJ29ic2VydmVyJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXIodm0pIHtcclxuICAgIGlmICh2bS4kX3ZlZU9ic2VydmVyKSB7XHJcbiAgICAgICAgdm0uJF92ZWVPYnNlcnZlci5vYnNlcnZlKHZtLCAnb2JzZXJ2ZXInKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBwcmVwYXJlU2xvdFByb3BzKHZtKSB7XHJcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHZtLmZsYWdzKSwgeyBlcnJvcnM6IHZtLmVycm9ycywgZmllbGRzOiB2bS5maWVsZHMsIHZhbGlkYXRlOiB2bS52YWxpZGF0ZSwgcGFzc2VzOiB2bS5oYW5kbGVTdWJtaXQsIGhhbmRsZVN1Ym1pdDogdm0uaGFuZGxlU3VibWl0LCByZXNldDogdm0ucmVzZXQgfSk7XHJcbn1cclxuLy8gQ3JlYXRlcyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdmFsaWRhdGlvbiBmbGFnc1xyXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZlckZsYWdzKCkge1xyXG4gICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjcmVhdGVGbGFncygpKSwgeyB2YWxpZDogdHJ1ZSwgaW52YWxpZDogZmFsc2UgfSk7XHJcbn1cclxuZnVuY3Rpb24gY29tcHV0ZU9ic2VydmVyU3RhdGUoKSB7XHJcbiAgICB2YXIgdm1zID0gX19zcHJlYWRBcnJheXModmFsdWVzKHRoaXMucmVmcyksIHRoaXMub2JzZXJ2ZXJzKTtcclxuICAgIHZhciBlcnJvcnMgPSB7fTtcclxuICAgIHZhciBmbGFncyA9IGNyZWF0ZU9ic2VydmVyRmxhZ3MoKTtcclxuICAgIHZhciBmaWVsZHMgPSB7fTtcclxuICAgIHZhciBsZW5ndGggPSB2bXMubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciB2bSA9IHZtc1tpXTtcclxuICAgICAgICAvLyB2YWxpZGF0aW9uIHByb3ZpZGVyXHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodm0uZXJyb3JzKSkge1xyXG4gICAgICAgICAgICBlcnJvcnNbdm0uaWRdID0gdm0uZXJyb3JzO1xyXG4gICAgICAgICAgICBmaWVsZHNbdm0uaWRdID0gX19hc3NpZ24oeyBpZDogdm0uaWQsIG5hbWU6IHZtLm5hbWUsIGZhaWxlZFJ1bGVzOiB2bS5mYWlsZWRSdWxlcyB9LCB2bS5mbGFncyk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBOZXN0ZWQgb2JzZXJ2ZXIsIG1lcmdlIGVycm9ycyBhbmQgZmllbGRzXHJcbiAgICAgICAgZXJyb3JzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGVycm9ycyksIHZtLmVycm9ycyk7XHJcbiAgICAgICAgZmllbGRzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGZpZWxkcyksIHZtLmZpZWxkcyk7XHJcbiAgICB9XHJcbiAgICBGTEFHU19TVFJBVEVHSUVTLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgdmFyIGZsYWcgPSBfYVswXSwgbWV0aG9kID0gX2FbMV07XHJcbiAgICAgICAgZmxhZ3NbZmxhZ10gPSB2bXNbbWV0aG9kXShmdW5jdGlvbiAodm0pIHsgcmV0dXJuIHZtLmZsYWdzW2ZsYWddOyB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgZXJyb3JzOiBlcnJvcnMsIGZsYWdzOiBmbGFncywgZmllbGRzOiBmaWVsZHMgfTtcclxufVxuXG5mdW5jdGlvbiB3aXRoVmFsaWRhdGlvbihjb21wb25lbnQsIG1hcFByb3BzKSB7XHJcbiAgICBpZiAobWFwUHJvcHMgPT09IHZvaWQgMCkgeyBtYXBQcm9wcyA9IGlkZW50aXR5OyB9XHJcbiAgICB2YXIgX2EsIF9iO1xyXG4gICAgdmFyIG9wdGlvbnMgPSAnb3B0aW9ucycgaW4gY29tcG9uZW50ID8gY29tcG9uZW50Lm9wdGlvbnMgOiBjb21wb25lbnQ7XHJcbiAgICB2YXIgcHJvdmlkZXJPcHRzID0gVmFsaWRhdGlvblByb3ZpZGVyLm9wdGlvbnM7XHJcbiAgICB2YXIgaG9jID0ge1xyXG4gICAgICAgIG5hbWU6IChvcHRpb25zLm5hbWUgfHwgJ0Fub255bW91c0hvYycpICsgXCJXaXRoVmFsaWRhdGlvblwiLFxyXG4gICAgICAgIHByb3BzOiBfX2Fzc2lnbih7fSwgcHJvdmlkZXJPcHRzLnByb3BzKSxcclxuICAgICAgICBkYXRhOiBwcm92aWRlck9wdHMuZGF0YSxcclxuICAgICAgICBjb21wdXRlZDogX19hc3NpZ24oe30sIHByb3ZpZGVyT3B0cy5jb21wdXRlZCksXHJcbiAgICAgICAgbWV0aG9kczogX19hc3NpZ24oe30sIHByb3ZpZGVyT3B0cy5tZXRob2RzKSxcclxuICAgICAgICBiZWZvcmVEZXN0cm95OiBwcm92aWRlck9wdHMuYmVmb3JlRGVzdHJveSxcclxuICAgICAgICBpbmplY3Q6IHByb3ZpZGVyT3B0cy5pbmplY3RcclxuICAgIH07XHJcbiAgICB2YXIgZXZlbnROYW1lID0gKChfYiA9IChfYSA9IG9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2RlbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmV2ZW50KSB8fCAnaW5wdXQnO1xyXG4gICAgaG9jLnJlbmRlciA9IGZ1bmN0aW9uIChoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHZhciBfYiwgX2M7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckZpZWxkKCk7XHJcbiAgICAgICAgdmFyIHZjdHggPSBjcmVhdGVWYWxpZGF0aW9uQ3R4KHRoaXMpO1xyXG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSBfX2Fzc2lnbih7fSwgdGhpcy4kbGlzdGVuZXJzKTtcclxuICAgICAgICB2YXIgbW9kZWwgPSBmaW5kTW9kZWwodGhpcy4kdm5vZGUpO1xyXG4gICAgICAgIHRoaXMuX2lucHV0RXZlbnROYW1lID0gdGhpcy5faW5wdXRFdmVudE5hbWUgfHwgZ2V0SW5wdXRFdmVudE5hbWUodGhpcy4kdm5vZGUsIG1vZGVsKTtcclxuICAgICAgICB2YXIgdmFsdWUgPSBmaW5kVmFsdWUodGhpcy4kdm5vZGUpO1xyXG4gICAgICAgIG9uUmVuZGVyVXBkYXRlKHRoaXMsIChfYiA9IHZhbHVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWUpO1xyXG4gICAgICAgIHZhciBfZCA9IGNyZWF0ZUNvbW1vbkhhbmRsZXJzKHRoaXMpLCBvbklucHV0ID0gX2Qub25JbnB1dCwgb25CbHVyID0gX2Qub25CbHVyLCBvblZhbGlkYXRlID0gX2Qub25WYWxpZGF0ZTtcclxuICAgICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgZXZlbnROYW1lLCBvbklucHV0KTtcclxuICAgICAgICBtZXJnZVZOb2RlTGlzdGVuZXJzKGxpc3RlbmVycywgJ2JsdXInLCBvbkJsdXIpO1xyXG4gICAgICAgIHRoaXMubm9ybWFsaXplZEV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldnQpIHtcclxuICAgICAgICAgICAgbWVyZ2VWTm9kZUxpc3RlbmVycyhsaXN0ZW5lcnMsIGV2dCwgb25WYWxpZGF0ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gUHJvcHMgYXJlIGFueSBhdHRycyBub3QgYXNzb2NpYXRlZCB3aXRoIFZhbGlkYXRpb25Qcm92aWRlciBQbHVzIHRoZSBtb2RlbCBwcm9wLlxyXG4gICAgICAgIC8vIFdBUk5JTkc6IEFjY2lkZW50YWwgcHJvcCBvdmVyd3JpdGUgd2lsbCBwcm9iYWJseSBoYXBwZW4uXHJcbiAgICAgICAgdmFyIHByb3AgPSAoZmluZE1vZGVsQ29uZmlnKHRoaXMuJHZub2RlKSB8fCB7IHByb3A6ICd2YWx1ZScgfSkucHJvcDtcclxuICAgICAgICB2YXIgcHJvcHMgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdGhpcy4kYXR0cnMpLCAoX2EgPSB7fSwgX2FbcHJvcF0gPSAoX2MgPSBtb2RlbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnZhbHVlLCBfYSkpLCBtYXBQcm9wcyh2Y3R4KSk7XHJcbiAgICAgICAgcmV0dXJuIGgob3B0aW9ucywge1xyXG4gICAgICAgICAgICBhdHRyczogdGhpcy4kYXR0cnMsXHJcbiAgICAgICAgICAgIHByb3BzOiBwcm9wcyxcclxuICAgICAgICAgICAgb246IGxpc3RlbmVyc1xyXG4gICAgICAgIH0sIG5vcm1hbGl6ZVNsb3RzKHRoaXMuJHNsb3RzLCB0aGlzLiR2bm9kZS5jb250ZXh0KSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGhvYztcclxufVxuXG52YXIgdmVyc2lvbiA9ICczLjIuNSc7XG5cbmV4cG9ydCB7IFZhbGlkYXRpb25PYnNlcnZlciwgVmFsaWRhdGlvblByb3ZpZGVyLCBjb25maWd1cmUsIGV4dGVuZCwgbG9jYWxlQ2hhbmdlZCwgbG9jYWxpemUsIG5vcm1hbGl6ZVJ1bGVzLCBzZXRJbnRlcmFjdGlvbk1vZGUsIHZhbGlkYXRlLCB2ZXJzaW9uLCB3aXRoVmFsaWRhdGlvbiB9O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vee-validate/dist/vee-validate.esm.js\n");

/***/ })

}]);